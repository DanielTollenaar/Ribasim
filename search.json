[
  {
    "objectID": "demo.html",
    "href": "demo.html",
    "title": "Bach",
    "section": "",
    "text": "The following examples demonstrate the impact of forcings and the user allocation functionality for a single free draining LSW. The examples are simulated with synthetic data to highlight the functionality of Bach, with the exception of example 1.8 and 1.9 which shows the Bach prototype simulation of the Hupsel LSW.\n\n1.1 No external forcing\n1.2 Precipitation\n1.3 Evaporation\n1.4 Precipitation and evaporation\n1.5 Infiltration\n1.6 Urban Runoff\n1.7 Allocation to multiple users\n1.8 Hupsel water balance (single LSW)\n1.9 Hupsel water balance comparison with Mozart\n\n\n\n\nThe following examples demonstrate the water management and user allocation functionality for a level controlled LSW. The simulations are simulated with synthetic data to highlight the functionality of Bach, with the exception of example 2.1 and 2.3 which show the Bach prototype simulation of the Tol LSW.\n\n2.1 Tol water balance (single LSW)\n2.2 Level Control and multiple users\n2.3 Tol water balance comparison with Mozart.\n\n\n\nCode\n# Set up for demo simulations\nusing Pkg\nPkg.activate(\"..\");\n# Load Julia Libraries\nusing AbbreviatedStackTraces\nusing Bach\nusing Duet\nusing Dates\nusing TOML\nusing Arrow\nusing DataFrames\nimport BasicModelInterface as BMI\nusing SciMLBase\nusing Graphs\nusing GLMakie\nusing CairoMakie\nusing Plots\nusing DataFrameMacros\n\n\n  Activating project at `c:\\Git\\bach`\n\n\n\n\n\n\n\nCode\n\n# Load TOML\nconfig = TOML.parsefile(\"../run.toml\");\n# Load LSW Forcings Data\nlswforcing = DataFrame(Arrow.Table(\"../data/input/6/forcing.arrow\"));\n\n\n\"data/input/6/forcing.arrow\"\n\n\n\n\nThis fictional free flowing LSW has no input or output forcing flux. The LSW empties according to the Volume-Area_Discharge relationship. The two examples below show the impact the profile has on the LSW drainage.\n\n\nCode\ncase = \"emptying_sloping_profile\"\n## Code\n## Set up\ndemoconfig = Dict{String,Any}()\nlsw_id = 1\ndemoconfig[\"lsw_ids\"] = [lsw_id]\ndemoconfig[\"update_timestep\"] = 86400.0\ndemoconfig[\"starttime\"] = Date(\"2022-01-01\")\ndemoconfig[\"endtime\"] = Date(\"2022-02-01\")\ndemoconfig[\"state\"] = DataFrame(location=lsw_id, volume=1e6)\ndemoconfig[\"static\"] = DataFrame(location=lsw_id, target_level=NaN, target_volume=NaN, depth_surface_water=NaN, local_surface_water_type='V')\ndemoconfig[\"forcing\"] = DataFrame(time=DateTime[], variable=Symbol[], location=Int[], value=Float64[])\ndemoconfig[\"profile\"] = DataFrame(location=lsw_id, volume=[0.0, 1e6], area=[1e6, 1e6], discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n## Simulate\nreg = BMI.initialize(Bach.Register, democonfig)\nsolve!(reg.integrator);\n# println(reg)\n\n## Plot Results\n\nfig_1a = Duet.plot_series(reg, lsw_id)\ndisplay(fig_1a)\n\n\n\n\n\n\n\nCode\ncase = \"emptying_steep_profile_Hupsel\"\n## Code\n## Set up\ndemoconfig = Dict{String,Any}()\nlsw_id = 1\ndemoconfig[\"lsw_ids\"] = [lsw_id]\ndemoconfig[\"update_timestep\"] = 86400.0\ndemoconfig[\"starttime\"] = Date(\"2022-01-01\")\ndemoconfig[\"endtime\"] = Date(\"2022-02-01\")\ndemoconfig[\"state\"] = DataFrame(location=lsw_id, volume=1e6)\ndemoconfig[\"static\"] = DataFrame(location=lsw_id, target_level=NaN, target_volume=NaN, depth_surface_water=NaN, local_surface_water_type='V')\ndemoconfig[\"forcing\"] = DataFrame(time=DateTime[], variable=Symbol[], location=Int[], value=Float64[])\n# profile from Hupsel\ndemoconfig[\"profile\"] = DataFrame(location =[1,1,1,1], volume=[0.0, 7427.697265625, 14855.39453125, 750197.375], area=[92152.2890625, 92152.2890625, 92152.2890625, 92152.2890625], discharge=[0.0, 0.0, 0.09600285440683365, 9.600285530090332], level= [18.909799575805664, 19.109800338745117, 19.309799194335938, 39.109798431396484])\n\n## Simulate\nreg = BMI.initialize(Bach.Register, democonfig)\nsolve!(reg.integrator);\n# println(reg)\n\n## Plot Results\n\nfig_1b = Duet.plot_series(reg, lsw_id)\ndisplay(fig_1b)\n\n\n\n\n\n\n\n\n\nThis fictional free flowing LSW is simulated with only the external forcing of synthetic precipitation data. The storage and the outflow respond to the preciptation as shown below.\n\n\nCode\ncase = \"precipitation\"\n## Code\n## Set up\ndemoconfig[\"starttime\"] = Date(\"2019-01-01\")\ndemoconfig[\"endtime\"] = Date(\"2020-01-01\")\ndummydata = @subset(lswforcing, :variable == Symbol(\"precipitation\"), :location == 151358, :time >= config[\"starttime\"], :time <= config[\"endtime\"])\ndummydata.location .= lsw_id\ndemoconfig[\"forcing\"] = DataFrame(time=dummydata.time, variable=dummydata.variable, location=dummydata.location, value=dummydata.value * 3) # Exaggerated for demo\ndemoconfig[\"profile\"] = DataFrame(location=lsw_id, volume=[0.0, 1e6], area=[1e6, 1e6], discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n# Simulate and Plot\nreg = BMI.initialize(Bach.Register, democonfig)\nsolve!(reg.integrator)  # solve it until the end\n# println(reg)\n\n# Plot\nfig_2 = Duet.plot_series(reg, lsw_id)\ndisplay(fig_2)\n\n\n\n\n\n\n\n\nThe LSW loses water from evaporation. Outflow occurs according to the VAD as in example 1.1, but overall volume decline is faster rate due to additional loss from evaporation. Evaporation does not occur in an empty LSW.\nThe second example shows the LSW with no simulated discharge, so that the only output is evaporation\n\n\nCode\ncase = \"evaporation\"\n## Code\n## Set up\nlsw_id = 1\ndemoconfig[\"starttime\"] = Date(\"2019-01-01\")\ndemoconfig[\"endtime\"] = Date(\"2019-06-01\")\ndummydata = @subset(lswforcing, :variable == Symbol(\"evaporation\"), :location == 151358)\ndemoconfig[\"forcing\"] = DataFrame(time=dummydata.time, variable=dummydata.variable, location=lsw_id, value=dummydata.value * 3)\ndemoconfig[\"profile\"] = DataFrame(location=lsw_id, volume=[0.0, 1e6], area=[1e6, 1e6], discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n## Simulate\nreg = BMI.initialize(Bach.Register, democonfig)\nsolve!(reg.integrator)  # solve it until the end\n# println(reg)\n\n## Plot\nfig_3 = Duet.plot_series(reg, lsw_id)\ndisplay(fig_3)\n\n\n\n\n\n\n\nCode\ncase = \"evaporation2\"\n# Code\n## Set up\n\nconfig = Dict{String,Any}()\nlsw_id = 1\nconfig[\"lsw_ids\"] = [lsw_id]\nconfig[\"update_timestep\"] = 86400.0\nstarttime = DateTime(\"2019-01-01\")\nconfig[\"starttime\"] = DateTime(\"2019-01-01\")\nconfig[\"endtime\"] = Date(\"2019-06-01\")\nconfig[\"state\"] = DataFrame(location=lsw_id, volume=1e6)\nconfig[\"static\"] = DataFrame(location=lsw_id, target_level=NaN, target_volume=NaN,\n    depth_surface_water=NaN, local_surface_water_type='V')\nconfig[\"forcing\"] = DataFrame(time=starttime, variable=:evaporation, location=lsw_id,\n    value=1e-6)\nconfig[\"profile\"] = DataFrame(location=lsw_id, volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 0.0], level=[10.0, 11.0])\n\n# Simulate\nreg = BMI.initialize(Bach.Register, config);\nsolve!(reg.integrator);  # solve it until the end\n\n# Plot\nfig_s = Duet.plot_series(reg, lsw_id)\ndisplay(fig_s)\n\n\n\n\n\nRegister(ts: 2159, t: 2019-06-01T00:00:00)\n\n\n\n\n\n\nThis example shows the evaporation and precipitation flux simulated together\n\n\nCode\ncase = \"evaporation_precipitation\"\n## Code\n## Set up\ndemoconfig[\"starttime\"] = Date(\"2019-01-01\")\ndemoconfig[\"endtime\"] = Date(\"2019-06-01\")\ndummydata_e = @subset(lswforcing, :variable == Symbol(\"evaporation\"), :location == 151358)\ndummydata_p = @subset(lswforcing, :variable == Symbol(\"precipitation\"), :location == 151358)\ndummydata = append!(dummydata_e, dummydata_p);\nsort!(dummydata, [order(:time, rev=false)]);\ndemoconfig[\"forcing\"] = DataFrame(time=dummydata.time, variable=dummydata.variable, location=lsw_id, value=dummydata.value * 3)\n\n## Simulate\nreg = BMI.initialize(Bach.Register, democonfig)\nsolve!(reg.integrator)  # solve it until the end\n# println(reg)\n\n## Plot\nfig_4 = Duet.plot_series(reg, lsw_id)\ndisplay(fig_4)\n\n\n\n\n\n\n\nInfiltration is a negative flux of the LSW. This example shows the LSW storage responding to an enhanced forcing of infiltration. There is no outflow simulated of this LSW, so that the only output is the infiltration\n\n\nCode\ncase = \"Infiltration\"\n## Code\n## Set up\nconfig = Dict{String,Any}()\nlsw_id = 1\nconfig[\"lsw_ids\"] = [lsw_id]\nconfig[\"update_timestep\"] = 86400.0\nstarttime = DateTime(\"2019-01-01\")\nconfig[\"starttime\"] = starttime\nconfig[\"endtime\"] = Date(\"2019-02-01\")\nconfig[\"state\"] = DataFrame(location=lsw_id, volume=1e6)\nconfig[\"static\"] = DataFrame(location=lsw_id, target_level=NaN, target_volume=NaN,\n    depth_surface_water=NaN, local_surface_water_type='V')\nconfig[\"forcing\"] = DataFrame(time=starttime, variable=:infiltration,\n    location=lsw_id, value=1.5e-6)\nconfig[\"profile\"] = DataFrame(location=lsw_id, volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 0.0], level=[10.0, 11.0])\n## Simulate\nreg = BMI.initialize(Bach.Register, config)\nsolve!(reg.integrator);  # solve it until the end\n\n## Plot\nfig_5 = Duet.plot_series(reg, lsw_id)\ndisplay(fig_5)\n\n\n\n\n\n\n\n\nUrban runoff is a surface water input to the LSW. In case of the Netherlands, this is not calculated by MODFLOW but by the unsaturated zone model MetaSWAP. This example shows the LSW storage responding to the influx forcing of urban runoff.\n\n\nCode\ncase = \"Urban Runoff\"\n## Code\n## Set up\ndemoconfig[\"starttime\"] = Date(\"2019-01-01\")\ndemoconfig[\"endtime\"] = Date(\"2019-06-01\")\ndummydata = @subset(lswforcing, :variable == Symbol(\"urban_runoff\"), :location == 151358)\ndummydata.value *= 3 # Emphasised to highlight the functionality\ndemoconfig[\"forcing\"] = DataFrame(time=dummydata.time, variable=dummydata.variable, location=lsw_id, value=dummydata.value * 3)\n\n## Simulate\nreg = BMI.initialize(Bach.Register, democonfig)\nsolve!(reg.integrator)  # solve it until the end\n#println(reg)\n\n## Plot\nfig_6 = Duet.plot_series(reg, lsw_id)\ndisplay(fig_6)\n\n\n\n\n\n\n\n\n\nThe allcoation is based upon demand and prioritisation of the users and the available water in the LSW. In a free flowing LSW only water from the LSW can be abstracted by the users: agriculture and industry. In this example there are two users. Agriculture has higher prioirty than industry, therefore when there is a shortage of available water, agriculture abstracts water before industry as demonstrated.\n\n\n\n\nSimulation 1.8 is for the LSW Hupsel. The LSW is a free flowing LSW.\n\n\n\n\nThe following two figures show Hupsel LSW water balance for the Bach prototype compared to the water balance simulated by Mozart, the precursor to Bach. The figures show a good agreement between the two simulations\n\n\n\n\n\n\nSimulation 2.1 is for the LSW Tol. The LSW is a level controlled meaning that water is allocated to maintain water levels at a target level.\n\n\n\n\nSimulation 2.2 is for a hypothetical level controlled LSW situation. This level control LSW has an additional users (agriculture) with a lower priority than the level control. In this scenario water is allocated to the users irder of priority, first based on the level of the LSW with respect to the target level, and additionally with water from the external network when required. The LSW is a level controlled meaning that water is allocated to maintain water levels at a target level.\n\n\nCode\ncase = \"LevelControl_MultipleUsers\"\n## Set up\n\n\n\n\n\n\nThe following two figures show Tol LSW water balance for the Bach prototype compared to the water balance simulated by Mozart, the precursor to Bach. The figures show a good agreement between the two simulations"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bach",
    "section": "",
    "text": "Bach is written in the Julia programming language and is built on top of the SciML: Open Source Software for Scientific Machine Learning libraries, notably ModelingToolkit.jl.\n\nStatus\nThe initial focus is on being able to reproduce the Mozart regional surface water reservoir results. Each component is defined by a set of symbolic equations, and can be connected to each other. From this a simplified system of equations is generated automatically. We use solvers with adaptive time stepping from DifferentialEquations.jl to get results.\n\n\n\nTimeseries of a single reservoir, with the input and output fluxes on the top, and the storage volume (the state) below.\n\n\n\n\n\nBar plot of the daily waterbalance, comparing Mozart (left) and Bach (right)."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Time\nThe water balance equation can be applied on many timescales; years, weeks, days or hours. Depending on the application and available data any of these can be the best choice. In Bach, we make use of DifferentialEquations.jl and can use any of its ODE solvers. Many of these solvers make use of adaptive time stepping, which means the solver will decide how large the time steps can be depending on the state of the system.\nThe forcing, like precipitation, is generally provided as a time series. Bach is set up to support unevenly spaced timeseries. The solver will stop on timestamps where new forcing values are available, so they can be loaded as the new value.\nSo Bach is essentially a continuous model, rather than daily or hourly. If you want to use hourly forcing, you only need to make sure that your forcing data contains hourly updates. The output frequency can be configured independently. To be able to write a closed water balance on e.g. a daily basis, we integrate the timeseries over the days. This way any variation inside of the days is also included, and we can output in m³ rather than m³s⁻¹.\n\n\nSpace\nThe water balance equation can be applied on different spatial scales. Besides modelling a single lumped watershed, it allows you to divide the area into a network of connected representative elementary watersheds (REWs) (Reggiani, Sivapalan, and Majid Hassanizadeh 1998). At this scale global water balance laws can be formulated by means of integration of point-scale conservation equations over control volumes. Such an approach makes Bach a semi-distributed model. In this document we typically use the term “basin” to refer to the REW. In Mozart the spatial unit was called Local Surface Water (LSW). Each basin has an associated polygon, and the set of basins is connected to each other as described by a graph, which we call the network. Below is a representation of both on the map.\n\n\n\nMozart Local Surface Water polygons and their drainage.\n\n\nThe network is described as graph. Flow can be bi-directional, and the graph does not have to be acyclic.\n\n\n\n\ngraph LR;\n    A[\"basin A\"] --- B[\"basin B\"];\n    A --- C[\"basin C\"];\n    B --- D[\"basin D\"];\n    C --- D;\n\n\n\n\n\n\n\n\nInternally a directed graph is used. The direction is defined to be the positive flow direction, and is often set in the dominant flow direction.\n\n\n\n\n\nReferences\n\nReggiani, Paolo, Murugesu Sivapalan, and S. Majid Hassanizadeh. 1998. “A Unifying Framework for Watershed Thermodynamics: Balance Equations for Mass, Momentum, Energy and Entropy, and the Second Law of Thermodynamics.” Advances in Water Resources 22 (4): 367–98. https://doi.org/https://doi.org/10.1016/S0309-1708(98)00012-8."
  },
  {
    "objectID": "modflow.html",
    "href": "modflow.html",
    "title": "Modflow",
    "section": "",
    "text": "Bach has been designed to provide a computationally efficient representation of surface water for MODFLOW6. It does so by connecting to basic MODFLOW6 boundary conditions: the river and drainage packages.\n\n\nThe drainage package can be simulated to agricultural drains, ditches, or draining streams. The amount of water removed from the aquifer is proportional to the difference between the groundwater head and the drainage elevation. Drainage only occurs when the head is larger than the elevation; this boundary condition does not allow infiltration into the groundwater.\n\\[\nQ_{drain} = \\left\\{\n    \\begin{array}{ c l }\n        C_{drain} (\\phi - h_{drain}) & \\quad \\textrm{if } \\phi > h_{drain} \\\\\n        0                            & \\quad \\textrm{otherwise}\n     \\end{array}\n\\right.\n\\]\n\n\n\nThe river package can both drain the groundwater, or infiltrate surface water to the groundwater. It limits the amount of water that can infiltrate when the groundwater head falls below the river bottom, in which cases it assumes atmospheric pressure conditions underneath the surface water.\n\\[\nQ_{river} = \\left\\{\n    \\begin{array}{ c l }\n        C_{river} (\\phi - h_{river}) & \\quad \\textrm{if } \\phi > b_{river} \\\\\n        C_{river} (h_{river} - b_{river}) & \\quad \\textrm{if } \\phi <= b_{river}\n     \\end{array}\n\\right.\n\\]\nIn the Netherlands, it is somewhat common to make a distinction between the drainage and infiltration conductance of surface waters. Drainage conductance is often larger than the infiltration conductance due to clogging processes, seepage through sides of the ditches, less contracted flow lines, etc.\n\\[\nQ_{river} = \\left\\{\n    \\begin{array}{ c l }\n        C_{river,drn} (\\phi - h_{river}) & \\quad \\textrm{if } \\phi > h_{river} \\\\\n        C_{river,inf} (\\phi - h_{river}) & \\quad \\textrm{if } \\phi <= h_{river} \\\\\n        C_{river,inf} (h_{river} - b_{river}) & \\quad \\textrm{if } \\phi <= b_{river}\n     \\end{array}\n\\right.\n\\]\nMODFLOW6 does not support this (currently), but an identical effect may be achieved by “stacking” a drainage package on top of a river package with these values:\n\\[\n\\begin{aligned}\nh_{drain} = h_{river}\nC_{drain} = C_{river,drn} - C{river,inf}\n\\end{aligned}\n\\]\n\n\n\nMODFLOW uses a backward-in-time implicit solution scheme. This creates a large system of equations (a water balance for every cell), which it solves by repeatedly solving a linearized system of equations instead. In matrix form, this system of equations is expressed by:\n\\[\n\\mathbf{Ax} = \\mathbf{b}\n\\]\nWhere \\(\\mathbf{x}\\) is a vector containing the head of every cell.\nFor the boundary conditions, this requires linearization of the flow equations. Flow from outside of the aquifer (cell) may be represented by:\n\\[\na = p\\phi + q\n\\]\n(Equation 2-6 in the MODFLOW6 documentation (Langevin et al. 2017).)\nFor e.g. a draining boundary condition, the flow is head dependent:\n\\[\na = C(h - \\phi) = -C\\phi + Ch\n\\]\nWith \\(C\\) the conductance, \\(h\\) the boundary head or elevation, and \\(\\phi\\) the groundwater head.\nIn MODFLOW’s internal formulation, the term in \\(\\mathbf{A}\\) is called “coefficient of head” or hcof. Terms in \\(\\mathbf{b}\\) are called “right hand side” or rhs. We can separate the equation above:\n\\[\n\\begin{aligned}\np = \\text{hcof} = -C \\\\\nq = \\textrm{rhs} = -Ch \\\\\na = -C\\phi + Ch = \\text{hcof} * \\phi - \\text{rhs}\n\\end{aligned}\n\\]\nFor every boundary condition, MODFLOW6 stores the hcof and rhs values. This makes it quite convenient for us to compute the water budget for every boundary condition: we simply multiply the hcof value by the head of the cell and subtract the rhs.\nNote that hcof may have a value of 0! For example, when for a river boundary the \\(\\phi <= b_{river}\\) condition occurs, the flow into the cell is controlled only by \\(h_{river}\\) and \\(b_{river}\\) (equal to recharge for the linear solution).\n\n\n\nWe can use a linearization to efficiently compute the flow from Bach’s side as well. In the iterative coupled solution, we are solving both MODFLOW6 and Bach repeatedly, until they produce same drainage or infiltration (approximately). One of Bach’s LocalSurfaceWaters contains many MODFLOW cells with boundary conditions. We could add every boundary condition to Bach’s equations, but this is costly and cumbersome.\nLinearization allows us to “stack” (superpose) all the different boundary conditions into a single, simple equation. In linear form, every equation takes the form of:\n\\[\na = ph + q\n\\]\nNote the \\(h\\) rather than \\(\\phi\\), we are formulating from Bach’s perspective! We can sum all coefficients for p and q to provide a linear groundwater response to Bach.\n\n\nFrom Bach’s perspective, the groundwater head is constant given a timestep, so that:\n\\[\n\\begin{align}\np = -C \\\\\nq = -C\\phi\n\\end{align}\n\\]\nWhen the head falls below the drainage elevation, the coefficients are 0.\n\n\n\nFrom Bach’s persective, infiltration is never limited when the head falls below the bottom:\n\\[\n\\begin{align}\np = -C \\\\\nq = -Cb\n\\end{align}\n\\]\nOtherwise, infiltration and drainage occur with the same equation as for the drainage package:\n\\[\n\\begin{align}\np = -C \\\\\nq = -C\\phi\n\\end{align}\n\\]"
  },
  {
    "objectID": "modflow.html#parametrization",
    "href": "modflow.html#parametrization",
    "title": "Modflow",
    "section": "Parametrization",
    "text": "Parametrization\nIn coupling Bach to MODFLOW6, relations translating the Bach volume must be given for every every cell of every boundary condition."
  },
  {
    "objectID": "modflow.html#examples",
    "href": "modflow.html#examples",
    "title": "Modflow",
    "section": "Examples",
    "text": "Examples\nTo get a feeling for the simplifications and the errors of the approximation, let’s consider three oversimplified hydraulic models:\n\nThe LSW has a single water level.\nThe LSW has a single water depth.\nThe LSW has a water depth that linearly decreases with bed elevation.\n\nTo investigate these cases, we will assume a rectangular profile (constant wetted area). This allows to create plots of cumulative wetted area versus height, so that the area between the water level and the bed elevation equals LSW volume."
  },
  {
    "objectID": "modflow.html#test-cases",
    "href": "modflow.html#test-cases",
    "title": "Modflow",
    "section": "Test cases",
    "text": "Test cases\nIn our test cases, we will work with the Dutch national groundwater model (LHM). For testing, we simplify the top boundary conditions to just three surface water “systems”, from large to small:\n\nPrimary\nSecondary\nTertiary\n\n(Note: Bach has no knowledge of these systems. Any basin is represented by a single volume.)\nThese systems are be separated due to their relatively small size in comparison with relatively coarse cells of the groundwater model: most cells in the LHM contain more than one surface water, and are included via representative parameters which take the physical scaling into account.\nIn case of sufficiently small cell sizes, no overlap occurs and all surface waters can be represented in a single grid.\nFor the purposes of testing, we have not created empirical volume-level relationships for the surface water of every cell. Instead, we have chosen for an (over)simplified representation over the hydraulic properties, which makes it easy to verify the behavior of Bach and the coupling procedures:\n\nPrimary, secondary, and tertiary systems have a rectangular profile: the area of the surface water does not change with water level or volume.\nWater depth is constant for a system within a basin.\nWater depth increases linearly with volume. (This follows from 1.)\nWater depth is distributed across the systems in a geometric progression: when the tertiary system contains 0.1 m of water, the secondary system contains 0.2 m, and the primary system contains 0.4 m.\nWater depth is 0.0 m for all systems when basin volume is 0.0. (This follows from 4.)\nThe distribution of water occurs according to the surface water area (width times length) used for the LHM parametrization of river bed conductance.\n\nAn example of the resulting parameters for a single cell is shown in Table 1. The first row shows the water levels when the basin is empty. The level for primary, secondary, and tertiary are equal to the bottom elevation of the surface waters. The second row shows the volume and levels for water depths of 0.4, 0.2, and 0.1 m. The third row shows the volume and levels for a tenfold larger volume. This results in implausible water levels with depths of 4.0, 2.0 and 1.0 m; the water level in the primary system is over two meters higher than in the tertiary system. In reality, the surface waters would overflow and surface ponding would occur; this mechanism is ignored in this case for the sake simplicity.\n\n\nTable 1: Volume-level table for a single cell in the Hupsel basin.\n\n\nVolume (m3)\nPrimary (m NAP)\nSecondary (m NAP)\nTertiary (m NAP)\n\n\n\n\n0.0\n25.65\n25.83\n26.60\n\n\n6843.1\n26.05\n26.03\n26.70\n\n\n68431.0\n29.65\n27.83\n27.60\n\n\n\n\nImage … shows the volume of the first row of the cell based input for the primary system. Symbology is set to unique values."
  },
  {
    "objectID": "modflow.html#budgets",
    "href": "modflow.html#budgets",
    "title": "Modflow",
    "section": "Budgets",
    "text": "Budgets\nTable … shows the budgets computed by MODFLOW6 per primary, secondary, and tertiary system. These are compared to the budget computed by the coupling procedure, which uses equation …\nAs expected, these numbers match exactly."
  },
  {
    "objectID": "modflow.html#zero-volume",
    "href": "modflow.html#zero-volume",
    "title": "Modflow",
    "section": "Zero volume",
    "text": "Zero volume"
  },
  {
    "objectID": "user_allocation.html",
    "href": "user_allocation.html",
    "title": "User Allocation",
    "section": "",
    "text": "General User\nThe General User category include the users Agriculture, Industry and Public Water supply. These users extract water from the LSW and the demand (\\(\\demuser\\)) is determined externally. The source of water allocated to the General User is dependent on if the LSW is a free-flowing type LSW or a level-controlled LSW.\nIf the LSW is free-flowing, the water source will be the available water within the LSW. If the LSW is level-controlled additional water can be sourced from the regional network, should the water available from the LSW be insufficient to satisfy \\(\\demuser\\).\nThe availability of water (\\(\\qavail\\)) internally in a LSW in a given timestep is calculated by Equation 1. This volume is available to be extracted by the General Users. In the Bach prototype, additional water from the regional network is currently modelled as an unlimited supply.\n\\[\n\\qavail = \\frac{(P - E_{pot}) \\cdot \\mathit{area}}{\\mathrm{Δ}t} - \\min(0, \\mathit{infiltration} - \\mathit{drainage} - \\mathit{urban\\_runoff})\n\\tag{1}\\]\nThe \\(\\qavail\\) can be assigned to multiple users in the same LSW. Allocation is based upon user priority. For a given user, in the case where \\(\\qavail > \\demuser\\), the user demand is satisfied and the remaining \\(\\qavail\\) becomes available for the user of next highest priority. For a given user, in the case where \\(\\demuser > \\qavail\\) then all of the available water is assigned to the user. This results in an allocation shortage and no remaining local water for any users of lower priority.\nHowever, as discussed, if the LSW is a level-controlled LSW, additional water can then be sourced from the regional network and is allocated to satisfy the allocation shortage of the General User.\n\n\nLevel Control\nA level-controlled LSW (local_surface_water_type = \"P\") has a user demand referred to as water management (\\(\\demwm\\)). The purpose of this demand is to maintain the water levels for each LSW at a target level. This target levels is determined externally. The \\(\\demwm\\) is negative if additional water is required to increase the water level in the LSW, or positive if there is surplus water which must be removed to lower the level in the LSW. When \\(\\demwm\\) is positive and there is surplus water, Bach is designed to make any surplus water available to General Users within the LSW for abstraction. This is modelled by adding the \\(\\demwm\\) to the \\(\\qavail\\) in calculated in Equation 2.\n\\[\n\\qavail = \\demwm\n\\tag{2}\\]\nWhen the \\(\\demwm\\) is negative, the \\(\\demwm\\) is allocated first from the LSW \\(\\qavail\\), and then secondly with water from the national network, should the local LSW water not be sufficient to satisfy \\(\\demwm\\). This demand is therefore handled similar to that of a General User. In the case that a General User is allocated water as a higher priority than the Level Control such that the water level of the LSW decreases, the \\(\\demwm\\) will increase accordingly. However, in most cases the demand for Level Control is higher than that of the General Users so this does not occur.\n\n\nFlushing Requirement\nThe flushing requirement for the LSW is a special case of user. Flushing is required to maintain water quality in the LSW. This is determined externally. Water from the national network flows into the LSW, and the same volume gets removed from the LSW back to the national network. This water cannot be allocated to other users and there is no net change to the water level in the LSW or the \\(\\qavail\\), see Equation 3.\n\\[\n\\mathit{Q_{in}} = -\\mathit{Q_{out}}\n\\tag{3}\\]"
  }
]