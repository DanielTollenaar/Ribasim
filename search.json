[
  {
    "objectID": "developer.html",
    "href": "developer.html",
    "title": "Dev docs",
    "section": "",
    "text": "1 System image\nThe Ribasim CLI is an executable that can be used without needing to install Julia itself. If you want to work from Julia, but want to reduce the latency when working with Ribasim.jl, an effective option is to work with system images. Like Ribasim CLI, they can also be created by PackageCompiler, see the sysimage docs.\nIn the Ribasim repository under compile/sysimage is a project prepared that allows you to create a system image. This project contains many package that are not only used for running Ribasim, but also to do post-processing such as plotting using Makie.\nPackageCompiler can be used directly, but for these instructions we will show you how to create such a system image from Visual Studio Code. For details see the julia-vscode docs.\nFirst, open the Ribasim repository in VS Code. Run the “Julia: Start REPL” command, which you can find using Ctrl+Shift+P. In the REPL, assuming pwd() returns the root of the repository, run ] activate compile/sysimage. Ribasim is a part of this project, but the package manager needs to be told that it resides at the root of the repository. This only needs to be done once, because then the path is contained in the Manifest.toml. Run ] rm Ribasim to remove it, and add it back using ] dev . Now run ] up to make sure you build a system image using the latest versions of the dependencies.\nThen, click “Julia env” in the bottom bar and select the compile/sysimage directory. Now use Ctrl+Shift+P and run “Tasks: Run Build Task”, followed by “Julia: Build custom sysimage for current environment”. This will take a while, as it will not only include the dependencies, but it will also run the code in compile/sysimage/precompile.jl, which includes a Ribasim run and plotting commands.\nIf successful, this will create a “JuliaSysimage” shared library file under compile/sysimage. Move this file to the root of the project. When opening the Ribasim repository in VS Code, it will use this system image based on the conditions described here.\nIf you want to use this system image when starting Julia from the command line, use -J, --sysimage <file> to start up with the given system image file. See all Julia command-line switches here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ribasim",
    "section": "",
    "text": "Ribasim is a water resources model, designed to be the replacement of the regional surface water modules Mozart and SIMRES in the Netherlands Hydrological Instrument (NHI). Ribasim is a work in progress, it is a prototype that demonstrates all essential functionalities. Further development of the prototype in a software release is planned in 2022 and 2023.\nRibasim is written in the Julia programming language and is built on top of the SciML: Open Source Software for Scientific Machine Learning libraries, notably ModelingToolkit.jl."
  },
  {
    "objectID": "index.html#water-balance-equations",
    "href": "index.html#water-balance-equations",
    "title": "Ribasim",
    "section": "2.1 Water balance equations",
    "text": "2.1 Water balance equations\nThe water balance equation for a drainage basin (Wikipedia contributors 2022) can be defined by a first-order ordinary differential equation (ODE), where the change of the storage \\(S\\) over time is determined by the inflow fluxes minus the outflow fluxes.\n\\[\n\\frac{\\mathrm{d}S}{\\mathrm{d}t} = Q_{in} - Q_{out}\n\\]\nWe can split out the fluxes into separate terms, such as precipitation \\(P\\), evapotranspiration \\(ET\\) and runoff \\(R\\). For now other fluxes are combined into \\(Q_{rest}\\). If we define all fluxes entering our reservoir as positive, and those leaving the system as negative, all fluxes can be summed up.\n\\[\n\\frac{\\mathrm{d}S}{\\mathrm{d}t} = R + P + ET + Q_{rest}\n\\]\nSuch a water balance ODE can be represented in ModelingToolkit.jl as follows:\nusing ModelingToolkit\n\n@variables t S(t) R(t) P(t) ET(t) Q_rest(t)  # independent and dependent variables\nD = Differential(t)       # define an operator for the differentiation w.r.t. time\n\nsys = ODESystem([D(S) ~ R + P + ET + Q_rest])\nOn the last line, an ODESystem is created that consists of a single equation. Before we can solve this, we need to create an ODEProblem, that provides information about the timespan of the simulation, as well as the initial conditions.\nRibasim can be used as a Julia package running in a Julia session or as an application initialized via a TOML configuration file. Both use cases are shown in the demonstrations."
  },
  {
    "objectID": "index.html#time",
    "href": "index.html#time",
    "title": "Ribasim",
    "section": "2.2 Time",
    "text": "2.2 Time\nThe water balance equation can be applied on many timescales; years, weeks, days or hours. Depending on the application and available data any of these can be the best choice. In Ribasim, we make use of DifferentialEquations.jl and its ODE solvers. Many of these solvers are based on adaptive time stepping, which means the solver will decide how large the time steps can be depending on the state of the system.\nThe forcing, like precipitation, is generally provided as a time series. Ribasim is set up to support unevenly spaced timeseries. The solver will stop on timestamps where new forcing values are available, so they can be loaded as the new value.\nRibasim is essentially a continuous model, rather than daily or hourly. If you want to use hourly forcing, you only need to make sure that your forcing data contains hourly updates. The output frequency can be configured independently. To be able to write a closed water balance, we accumulate the fluxes. This way any variations in between timesteps are also included, and we can output in m³ rather than m³s⁻¹."
  },
  {
    "objectID": "index.html#sec-space",
    "href": "index.html#sec-space",
    "title": "Ribasim",
    "section": "2.3 Space",
    "text": "2.3 Space\nThe water balance equation can be applied on different spatial scales. Besides modelling a single lumped watershed, it allows you to divide the area into a network of connected representative elementary watersheds (REWs) (Reggiani, Sivapalan, and Majid Hassanizadeh 1998). At this scale global water balance laws can be formulated by means of integration of point-scale conservation equations over control volumes. Such an approach makes Ribasim a semi-distributed model. In this document we typically use the term “basin” to refer to the REW. (In Mozart the spatial unit was called Local Surface Water (LSW)). Each basin has an associated polygon, and the set of basins is connected to each other as described by a graph, which we call the network. Below is a representation of both on the map.\n\n\n\nMozart Local Surface Water polygons and their drainage.\n\n\nThe network is described as graph. Flow can be bi-directional, and the graph does not have to be acyclic.\n\n\n\n\ngraph LR;\n    A[\"basin A\"] --- B[\"basin B\"];\n    A --- C[\"basin C\"];\n    B --- D[\"basin D\"];\n    C --- D;\n\n\n\n\n\n\n\n\nInternally a directed graph is used. The direction is defined to be the positive flow direction, and is generally set in the dominant flow direction. The basins are the nodes of the network graph. Basin states and properties such storage volume and wetted area are associated with the nodes (A, B, C, D), as are most forcing data such as precipitation, evaporation, or water demand. Basin connection properties and interbasin flows are associated with the edges (the lines between A, B, C, and D) instead.\nMultiple basins may exist within the same spatial polygon, representing different aspects of the surface water system (perennial ditches, ephemeral ditches, or even surface ponding). Figure 1, Figure 2, Figure 3 show the 25.0 m rasterized primary, secondary, and tertiary surface waters as identified by BRT TOP10NL (PDOK 2022) in the Hupsel basin (as defined in the Mozart LSW’s). These systems may represented in multiple ways.\n\n\n\nFigure 1: Hupsel: primary surface water.\n\n\n\n\n\nFigure 2: Hupsel: secondary surface water.\n\n\n\n\n\nFigure 3: Hupsel: tertiary surface water.\n\n\nAs a single basin (A) containing all surface water, discharging to its downstream basin to the west (B):\n\n\n\n\ngraph LR;\n    A[\"basin A\"] --> B[\"basin B\"];\n\n\n\n\n\n\n\n\nSuch a system may be capable of representing discharge, but it cannot represent residence times or differences in solute concentrations: within a single basin, drop of water is mixed instantaneously. Instead, we may the group primary (P), secondary (S), and tertiary (T) surface waters. Then T may flow into S, S into P, and P discharges to the downstream basin (B.)\n\n\n\n\ngraph LR;\n    T[\"basin T\"] --> S[\"basin S\"];\n    S --> P[\"basin P\"]; \n    P --> B[\"basin B\"];\n\n\n\n\n\n\n\n\nAs each (sub)basin has its own volume, low throughput (high volume, low discharge, long residence time) and high throughput (low volume, high discharge, short residence time) systems can be represented in a lumped manner; of course, more detail requires more parameters."
  },
  {
    "objectID": "index.html#installing-the-compiled-executable",
    "href": "index.html#installing-the-compiled-executable",
    "title": "Ribasim",
    "section": "3.1 Installing the compiled executable",
    "text": "3.1 Installing the compiled executable\nBinaries of Ribasim CLI (command-line interface) can be downloaded from ribasim-artifacts, and are currently available for Windows only. Download and unpack the .zip file. It can be placed anywhere, however it is important that the contents of the zip file are kept together in a directory. The Ribasim CLI executable is in the bin directory.\nTo check whether the installation was performed successfully, run ribasim with no arguments in the command line. This will give the following message:\nUsage: ribasim 'path/to/config.toml'\n\n\n\n\n\n\nNote\n\n\n\nThe binaries are currently not up to date with the latest developments; we suggest installing as a Julia package instead."
  },
  {
    "objectID": "index.html#installing-as-a-julia-package",
    "href": "index.html#installing-as-a-julia-package",
    "title": "Ribasim",
    "section": "3.2 Installing as a Julia package",
    "text": "3.2 Installing as a Julia package\nRibasim is a Julia package, that can be installed using Julia’s built in package manager, Pkg. For more information on how to use Pkg, see the Getting Started page in its documentation.\nSince Ribasim is not yet registered in the General registry, you have to install it using the full url. Note that we here use dev to do a development install.\npkg> dev https://github.com/Deltares/Ribasim.jl\nThis will clone the git repository, put it under your home directory in .julia/dev/Ribasim, and add the Ribasim package to your project environment. In order to receive updates, you have to pull in the latest changes yourself using git pull.\nInstallation may take a while since Pkg is also installing and pre-compiling the dependencies of Ribasim.\nOnce it is done, you can go back the Julia REPL and try to load Ribasim:\njulia> using Ribasim\nIf you already have a simulation prepared, you can run it using:\njulia> Ribasim.run(\"path/to/config.toml\")\nAgain, there will be considerable latency. For this reason, if you expect to run Ribasim a lot, we recommend to:\n\nUse Ribasim CLI if you only need Ribasim.run and don’t need to do developments.\nAdapt a workflow that keeps your session active; the first Ribasim.run(\"model.toml\") will take considerably more time than the second one, since more code needs to be compiled.\nUse a system image as explained in the developer documentation to reduce latency further\n\n\n\n\n\n\n\nTip: Visual Studio Code\n\n\n\nThere is a section on editors and IDEs for Julia on https://julialang.org/, scroll down to see it. We use and recommend Microsoft’s free editor Visual Studio Code. When combined with the Julia extension it provides a powerful and interactive development experience.\n\n\n\n\n\n\n\n\nTip: Revise.jl\n\n\n\nIf you plan to make changes to the code of Ribasim, we recommend installing the Revise.jl package. This package allows you to modify code and use the changes without restarting Julia. Install it with add Revise from the Pkg REPL. Then create a file called .julia/config/startup.jl, and put using Revise there. This will load Revise every time you start a Julia session."
  },
  {
    "objectID": "index.html#input-and-output-files",
    "href": "index.html#input-and-output-files",
    "title": "Ribasim",
    "section": "3.3 Input and output files",
    "text": "3.3 Input and output files\n\n3.3.1 Configuration file\nRibasim has a single configuration file, which is written in the TOML format. It contains settings, as well as paths to other input and output files.\n# start- and endtime of the simulation\n# can also be set to a date-time like 1979-05-27T07:32:00\nstarttime = 2019-01-01\nendtime = 2021-01-01\n\n# run a coupled Ribasim - MODFLOW 6 simulation\nrun_modflow = false  # default is false\n\n# all timesteps are in seconds\n# do water allocation for this time horizon\nupdate_timestep = 86400.0\n# save output at this interval\noutput_timestep = 86400.0  # default is 86400.0\n# save timesteps at this interval\n# note that this is internal, and is forwarded to the DiffEq solver options\n# https://diffeq.sciml.ai/stable/basics/common_solver_opts/#Output-Control\nsaveat = 86400.0  # default is to save every step\n\n# node IDs that will be included in the simulation\n# these node IDs are referenced in the input files below\nids = [1, 2, 3]\n\n# input files\nforcing = \"input/forcing.arrow\"\nstate = \"input/state.arrow\"\nstatic = \"input/static.arrow\"\nprofile = \"input/profile.arrow\"\nnode = \"input/node.arrow\"\nedge = \"input/edge.arrow\"\n\n# output file\nwaterbalance = \"output/waterbalance.arrow\"\nAdditionally, if run_modflow = true, a MODFLOW 6 specific section needs to be added to the configuration file. This part is documented in the MODFLOW 6 coupling demo.\n\n\n3.3.2 Arrow files\nThe input and output files described below all share that they are tabular files, stored in the Apache Arrow file format, also known as Feather files. This format has been chosen since it is standardized, fast, simple and flexible. It can be read and written by many different software packages. In Ribasim we use Arrow.jl.\nBelow we give details per file, in which we describe the schema of the table using a syntax like this:\n\n\n\ncolumn\ntype\nrestriction\n\n\n\n\nid\nInt\n-\n\n\nvolume\nFloat64\nnon-negative\n\n\n\nThis means that two columns are required, one named id, that contained elements of type Int, and a column named volume that contains elements of type Float64. The order of the columns does not matter, and the files are also allowed to have extra columns, which will be ignored. In some cases there may be restrictions on the values or the ordering of the rows. This is indicated under restriction.\nTables are also allowed to have rows for IDs, variables or times that are not part of the simulation, these will be ignored. That makes it easy to prepare data for a larger region once, and test models on a subset of the basins.\nThe Arrow input files can be compressed with LZ4 or Zstd compression. Furthermore, in some of the columns, a small amount of different values are repeated many times. To reduce file sizes it may be a good idea to apply dictionary encoding to those columns.\n\n\n3.3.3 Node\nSince we build Ribasim on top of ModelingToolkit, we can do component-based modeling. The components here are systems, typically ODESystem. These components are connected together to form a larger system. This is similar to the way a network has nodes that are connected along edges. We mostly use the terms node and edge in this text.\nUseful nodes can be water body storages that keep their own water balance, weirs, pumps, users or suppliers of water. Counter intuitively, even systems you may think of as edges, such as a canal, are nodes in Ribasim. This is because edges only define direct instantaneous couplings between nodes, and never have storage of their own.\n\n\n\ncolumn\ntype\nrestriction\n\n\n\n\nid\nInt\nunique\n\n\nnode\nString\nknown type\n\n\ngeometry\ngeoarrow\n(optional)\n\n\n\nThe schema of the node table shows that only a unique ID and known node type need to be given. The known node types as of this writing are:\n\nLSW\nGeneralUser_P\nLevelControl\nGeneralUser\nOutflowTable\nHeadBoundary\nBifurcation\nLevelLink\n\nAdding a geometry to the node table can be helpful to examine models in QGIS, as it will show the location of the nodes on the map. Geometries can be encoded in Arrow files according to the geoarrow specifications (still in flux). The geometry is not used by Ribasim.\n\n\n3.3.4 Edge\nEdges define so called connections, created in ModelingToolkit using the connect function. If defined between two flow connectors, they equate the level \\(h\\), conserve the flux \\(Q\\), and carry the salinity \\(C\\) in the flow direction. When defined between storage connectors, they can function simply as a way to share available storage \\(S\\) information from a reservoir to a water user, such that it can avoid overextraction.\n\n\n\ncolumn\ntype\nrestriction\n\n\n\n\nfrom_id\nInt\n-\n\n\nfrom_node\nString\nknown type\n\n\nfrom_connector\nString\nexists for node\n\n\nto_id\nInt\n-\n\n\nto_node\nString\nknown type\n\n\nto_connector\nString\nexists for node\n\n\ngeometry\ngeoarrow\n(optional)\n\n\n\nThe names of the connectors need to match the available connectors per node type, which are outlined below.\n\nLSW\n\nx: flow\ns: storage\n\nGeneralUser_P\n\na: flow\ns_a: storage\n\nLevelControl\n\na: flow\n\nGeneralUser\n\nx: flow\ns: storage\n\nOutflowTable\n\na: upstream flow\nb: downstream flow\ns: storage\n\nHeadBoundary\n\nx: flow\n\nBifurcation\n\nsrc: inflow\ndst_{i}: split outflow in n parts\n\nLevelLink\n\na: flow on one side\nb: flow on other side\n\n\nSimilarly to the node table, you can use a geometry to visualize the connections between the nodes in QGIS. For instance, you can draw a line connecting the two node coordinates.\n\n\n3.3.5 State\nThe state table aims to capture the full state of the system, such that it can be used as an initial condition, that is potentially the outcome of an earlier simulation. Currently the only states are the volume \\(S\\) and salinity \\(C\\) of the LSW node.\n\n\n\ncolumn\ntype\nrestriction\n\n\n\n\nid\nInt\n-\n\n\nS\nFloat64\nnon-negative\n\n\nC\nFloat64\nnon-negative\n\n\n\nEach used ID needs to be in the table.\n\n\n3.3.6 Static\nThe static table can be used to set the initial value of variables. The forcing table has a similar schema, with the time column added. If a variable is in the static table, it can still be added to the forcing as well, which will update the inital value when the given timestamp is reached.\n\n\n\ncolumn\ntype\nrestriction\n\n\n\n\nid\nInt\n-\n\n\nvariable\nString\n-\n\n\nvalue\nFloat64\ndepending on variable\n\n\n\nNote that if variables are not set in the static table, default values are used when possible. These are generally zero, e.g. no precipitation, no inflow. If it is not possible to have a reasonable and safe default, a value must be provided in the static table. An example of this is the target_volume from the LevelLink node.\n\n\n3.3.7 Forcing\nAll dynamic data can be added to the forcing table.\n\n\n\ncolumn\ntype\nrestriction\n\n\n\n\ntime\nDateTime\nsorted\n\n\nid\nInt\n-\n\n\nvariable\nString\n-\n\n\nvalue\nFloat64\ndepending on variable\n\n\n\nHere is an example of the first and last two rows of a forcing table:\n\n\n\ntime\nid\nvariable\nvalue\n\n\n\n\n2019-01-01T00:00:00\n6\nP\n2.89352e-10\n\n\n2019-01-01T00:00:00\n16\nP\n2.89352e-10\n\n\n⋮\n⋮\n⋮\n⋮\n\n\n2020-12-31T00:00:00\n90\nE_pot\n1.15741e-9\n\n\n2020-12-31T00:00:00\n7\nE_pot\n1.15741e-9\n\n\n\nThe forcing table is a narrow table. When the simulation arrives at a time given in the forcing data, it will update all the values given for that time. These values then stay constant until the next update, there is no interpolation in between. This also means that if a value is defined before the start of the simulation, it is completely ignored. This format give maximum flexibility to update different variables at different times.\n\n\n3.3.8 Profile\nThe profile table defines the physical dimensions of the storage reservoir of each basin. Depending on the basin type, the columns are used differently. For free draining basins, the level is not used in the calculation, but may be used to convert calculated volumes to levels for output. For level controlled basins, the discharge is not used.\n\n\n\ncolumn\ntype\nunit\nrestriction\n\n\n\n\nid\nInt\n-\nsorted\n\n\nvolume\nFloat64\n\\(m^3\\)\nsorted per ID and start at 0\n\n\narea\nFloat64\n\\(m^2\\)\nsorted per ID and non-negative\n\n\ndischarge\nFloat64\n\\(m^3 s^{-1}\\)\nsorted per ID and non-negative\n\n\nlevel\nFloat64\n\\(m\\)\nsorted per ID\n\n\n\nThe level is in meters above a datum that is the same for the entire model. An example of the first 5 rows of such a table is given below. The first 4 rows define the profile of ID 10020. The number of rows can vary per ID. Using a very large number of rows may impact performance.\n\n\n\nid\nvolume\narea\ndischarge\nlevel\n\n\n\n\n10020\n0.0\n1.36404e5\n0.0\n-0.105\n\n\n10020\n24726.2\n1.36404e5\n0.0\n0.095\n\n\n10020\n49452.5\n1.36404e5\n0.00942702\n0.295\n\n\n10020\n2.49735e6\n1.36404e5\n0.942702\n20.095\n\n\n10037\n0.0\n50663.3\n0.0\n2.129\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nProfiles need to be defined for all LSW and OutflowTable node. OutflowTable uses only volume and discharge, whereas LSW uses volume, area and level. These may be split up in the future.\n\n\n\n\n3.3.9 Water balance\nThe water balance table outputs all water balance terms at a regular output frequency, as defined by output_timestep in the configuration file. The units are \\(m^3\\), which is the total volume of flow into the basin since the previous output timestep. The inital timestep of the simulation, with all values set to zero, is also written to the file. Since flow out of the basin is given a negative value, and the storage change is included, you can sum all components to verify the closure of the water balance.\n\n\n\ncolumn\ntype\nrestriction\n\n\n\n\ntime\nDateTime\nsorted\n\n\nid\nInt\n-\n\n\nvariable\nString\n-\n\n\nvalue\nFloat64\nnon-negative volume (\\(m^3\\))\n\n\n\nThe water balance table has the same schema as the forcing table. Since the output frequency is constant, and equal for all variables, you can pivot this table from narrow to wide data to get the different water balance components as columns. Having them as a narrow table can make it easier to process, since for a given model you may not know the water balance components ahead of time."
  },
  {
    "objectID": "index.html#example-input-files",
    "href": "index.html#example-input-files",
    "title": "Ribasim",
    "section": "3.4 Example input files",
    "text": "3.4 Example input files\nFrom this link you can download an existing schematization for the Netherlands that was used for testing purposes during development. It is provided here as an example to help people get started. Based on the description of the input files above, you can also generate your own schematization using your tools of choice. We have used DataFrames.jl and Arrow.jl to prepare the tables, but one can equally use for instance Python’s pandas."
  },
  {
    "objectID": "modflow.html",
    "href": "modflow.html",
    "title": "MODFLOW 6 Coupling",
    "section": "",
    "text": "Ribasim has been designed to provide a computationally efficient representation of surface water for MODFLOW 6. It does so by connecting to basic MODFLOW 6 boundary conditions: the river and drainage packages.\nRibasim connects to MODFLOW 6 via the Basic Model Interface (BMI) and Extended Model Interface (XMI) (Hughes et al. 2022). BMI describes the interface to initialize a model, get values from its memory, run a timestep, etc. XMI extends this interface to allow much finer control into MODFLOW 6’s solution procedures. We have written a Julia package (Deltares 2022) which implements this interface for the Julia programming language. In coupling, Ribasim uses this interface to get the head values, the boundary condition water levels, and the budgets term of the MODFLOW 6 groundwater model while MODFLOW 6 is running.\nAdditionally, links can be made with other (BMI/XMI-compliant) processes and models. One example of such a link is using the surface runoff and the agricultural irrigation demand calculated by an unsaturated zone model; in the Netherlands Hydrological Instrument MetaSWAP provides this demand."
  },
  {
    "objectID": "modflow.html#drainage",
    "href": "modflow.html#drainage",
    "title": "MODFLOW 6 Coupling",
    "section": "1.1 Drainage",
    "text": "1.1 Drainage\nThe drainage package can be simulated to agricultural drains, ditches, or draining streams. The amount of water removed from the aquifer is proportional to the difference between the groundwater head and the drainage elevation. Drainage only occurs when the head is larger than the elevation; this boundary condition does not allow infiltration into the groundwater.\n\\[\nQ_{drain} = \\left\\{\n    \\begin{array}{ c l }\n        C_{drain} (\\phi - h_{drain}) & \\quad \\textrm{if } \\phi > h_{drain} \\\\\n        0                            & \\quad \\textrm{otherwise}\n     \\end{array}\n\\right.\n\\]"
  },
  {
    "objectID": "modflow.html#river",
    "href": "modflow.html#river",
    "title": "MODFLOW 6 Coupling",
    "section": "1.2 River",
    "text": "1.2 River\nThe river package can both drain the groundwater, or infiltrate surface water to the groundwater. It limits the amount of water that can infiltrate when the groundwater head falls below the river bottom, in which cases it assumes atmospheric pressure conditions underneath the surface water.\n\\[\nQ_{river} = \\left\\{\n    \\begin{array}{ c l }\n        C_{river} (\\phi - h_{river}) & \\quad \\textrm{if } \\phi > b_{river} \\\\\n        C_{river} (h_{river} - b_{river}) & \\quad \\textrm{if } \\phi <= b_{river}\n     \\end{array}\n\\right.\n\\]\nIn the Netherlands, it is somewhat common to make a distinction between the drainage and infiltration conductance of surface waters. Drainage conductance is often larger than the infiltration conductance due to clogging processes, seepage through sides of the ditches, less contracted flow lines, etc.\n\\[\nQ_{river} = \\left\\{\n    \\begin{array}{ c l }\n        C_{river,drn} (\\phi - h_{river}) & \\quad \\textrm{if } \\phi > h_{river} \\\\\n        C_{river,inf} (\\phi - h_{river}) & \\quad \\textrm{if } \\phi <= h_{river} \\\\\n        C_{river,inf} (h_{river} - b_{river}) & \\quad \\textrm{if } \\phi <= b_{river}\n     \\end{array}\n\\right.\n\\]\nMODFLOW 6 does not support this (currently), but an identical effect may be achieved by “stacking” a drainage package on top of a river package with these values:\n\\[\n\\begin{array}{ c l }\n  h_{drain} = h_{river} \\\\\n  C_{drain} = C_{river,drn} - C_{river,inf}\n\\end{array}\n\\]"
  },
  {
    "objectID": "modflow.html#numerical-solution-in-modflow",
    "href": "modflow.html#numerical-solution-in-modflow",
    "title": "MODFLOW 6 Coupling",
    "section": "2.1 Numerical solution in MODFLOW",
    "text": "2.1 Numerical solution in MODFLOW\nMODFLOW uses a backward-in-time implicit solution scheme. This creates a large system of equations (a water balance for every cell), which it solves by repeatedly solving a linearized system of equations instead. In matrix form, this system of equations is expressed by:\n\\[\n\\mathbf{Ax} = \\mathbf{b}\n\\]\nWhere \\(\\mathbf{x}\\) is a vector containing the head of every cell.\nFor the boundary conditions, this requires linearization of the flow equations. Flow from outside of the aquifer (cell) may be represented by:\n\\[\na = p\\phi + q\n\\]\n(Equation 2-6 in the MODFLOW 6 documentation (Langevin et al. 2017).)\nFor e.g. a draining boundary condition, the flow is head dependent:\n\\[\na = C(h - \\phi) = -C\\phi + Ch\n\\]\nWith \\(C\\) the conductance, \\(h\\) the boundary head or elevation, and \\(\\phi\\) the groundwater head.\nIn MODFLOW’s internal formulation, the term in \\(\\mathbf{A}\\) is called “coefficient of head” or hcof. Terms in \\(\\mathbf{b}\\) are called “right hand side” or rhs. We can separate the equation above:\n\\[\n\\begin{aligned}\np = \\text{hcof} = -C \\\\\nq = \\textrm{rhs} = -Ch \\\\\na = -C\\phi + Ch = \\text{hcof} * \\phi - \\text{rhs}\n\\end{aligned}\n\\]\nFor every boundary condition, MODFLOW 6 stores the hcof and rhs values. This makes it quite convenient for us to compute the water budget for every boundary condition: we simply multiply the hcof value by the head of the cell and subtract the rhs.\nNote that hcof may have a value of 0! For example, when for a river boundary the \\(\\phi <= b_{river}\\) condition occurs, the flow into the cell is controlled only by \\(h_{river}\\) and \\(b_{river}\\) (equal to recharge for the linear solution)."
  },
  {
    "objectID": "modflow.html#sequential-coupled-solution",
    "href": "modflow.html#sequential-coupled-solution",
    "title": "MODFLOW 6 Coupling",
    "section": "2.2 Sequential coupled solution",
    "text": "2.2 Sequential coupled solution\nA coupled run stars by initializing both models and creating the exchange information: which MODFLOW 6 boundary condition is connected to which Ribasim basin. While the model is running, the model proceeds through time as follows:\n\nRibasim solves the equations on a basin level; this occurs with adaptive timestepping via ModelingToolkit.\nAt a specified time (in accordance with the MODFLOW 6 time discretization), the volumes are converted to MODFLOW 6 boundary condition levels using a Callback function.\nMODFLOW 6 runs a timestep.\nThe drainage and infiltration budgets are computed from MODFLOW 6 using the equations described above and aggregated per basin.\nThe aggregated values are set as Ribasim boundary conditions, and Ribasim solves until the next preset exchange time.\n\nThese steps run until the final timestep is finished."
  },
  {
    "objectID": "modflow.html#iterative-coupled-solution",
    "href": "modflow.html#iterative-coupled-solution",
    "title": "MODFLOW 6 Coupling",
    "section": "2.3 Iterative coupled solution",
    "text": "2.3 Iterative coupled solution\n\n\n\n\n\n\nNote\n\n\n\nWe have not implemented an iterative coupled solution yet. The section below describes an approach.\n\n\nThe simplest form of a iterative solution occurs as follows:\n\nMODFLOW 6 computes drainage and infiltration flows.\nRibasim uses these flows to compute a storage volume for the basin.\nThe volume is translated to a water level for every MODFLOW 6 boundary condition in the basins.\nMODFLOW 6 recomputes drainage and infiltration flows with the updated water levels, etc.\n\nSuch a scheme is not maximally efficient: the discharge and infiltration terms are not constant, but are driven by a head difference. This head difference depends on the level of the boundary conditions and head of every cell of the groundwater model. If the surface waters of a basin empty, the water level will decrease and drainage and infiltration flows will change. Ideally, we can provide Ribasim with more information, so that it may estimate drainage and infiltration terms better.\nAs groundwater flow is often (approximately) linear, we can use linearization to more efficiently compute the flow from Ribasim’s side as well. In the iterative coupled solution, we are solving both MODFLOW 6 and Ribasim repeatedly, until they produce same drainage or infiltration (approximately). One of Ribasim’s basins contains many MODFLOW cells with boundary conditions. We could add every boundary condition to Ribasim’s equations, but this is costly and cumbersome. Fortunately, linearization allows us to “stack” (superpose) all the different boundary conditions into a single, simple equation. In linear form, every equation takes the form of:\n\\[\na = ph + q\n\\]\nNote the \\(h\\) rather than \\(\\phi\\), we are formulating from Ribasim’s perspective! We can sum all coefficients for p and q to provide a linear groundwater response to Ribasim.\n\n2.3.1 Drainage\nFrom Ribasim’s perspective, the groundwater head is constant given a timestep, so that:\n\\[\n\\begin{align}\np = -C \\\\\nq = -C\\phi\n\\end{align}\n\\]\nWhen the head falls below the drainage elevation, the coefficients are 0.\n\n\n2.3.2 River\nFrom Ribasim’s persective, infiltration is never limited when the head falls below the bottom:\n\\[\n\\begin{align}\np = -C \\\\\nq = -Cb\n\\end{align}\n\\]\nOtherwise, infiltration and drainage occur with the same equation as for the drainage package:\n\\[\n\\begin{align}\np = -C \\\\\nq = -C\\phi\n\\end{align}\n\\]"
  },
  {
    "objectID": "modflow.html#parametrization",
    "href": "modflow.html#parametrization",
    "title": "MODFLOW 6 Coupling",
    "section": "3.1 Parametrization",
    "text": "3.1 Parametrization\nIn coupling Ribasim to MODFLOW 6, relations translating the Ribasim volume must be given for every every cell of every boundary condition. These consist of piecewise linear relationships between the basin volume and its associated water level for the boundary condition in the cell.\nThese values are stored in a netCDF dataset. This dataset must meet the following requirements:\n\nIt must contain a x and y coordinate. The extent and cell size of these coordinates must match the domain of the coupled MODFLOW 6 model exactly.\nIt must contain a variable (x, y) denoting the basin IDs.\nIt must contain a volume-level variable (x, y, row, column) for every coupled MODFLOW 6 boundary condition, describing the volume-level lookup table per cell.\n\n\n\n\n\n\n\nNote\n\n\n\nThe x and y coordinates are valid for structured MODFLOW 6 models (DIS). Discretized-by-vertices (DISV) and fully unstructured discretization (DISU). are not yet supported, but require no fundamental changes: one basin is connected to multiple MODFLOW 6 cells, and the coupling parameters must match the (structured, unstructured) grid of the MODFLOW 6 model exactly.\n\n\nThe MODFLOW 6 coupling example cases show examples of such a parametrization."
  },
  {
    "objectID": "demo.html",
    "href": "demo.html",
    "title": "Ribasim",
    "section": "",
    "text": "On this page we present a range of mostly synthetic models, set up to highlight individual functionalities of Ribasim. The demonstrations are divided across two sections, in Section 2 free-flowing basins are used, which can drain freely to a downstream basin. In Section 3 level controlled basins are used. Here there is no free drainage, but water levels are controlled by water management, such as pumping. Note that this is the only difference between both, so all other functionality equally applies to free draining and level controlled basins."
  },
  {
    "objectID": "demo.html#sec-free-no",
    "href": "demo.html#sec-free-no",
    "title": "Ribasim",
    "section": "2.1 No external forcing",
    "text": "2.1 No external forcing\nThis fictional free flowing LSW has no input or output forcing flux. The LSW empties according to the Volume-Area-Discharge relationship. The two examples below show the impact the profile has on the LSW drainage.\n\n\nCode\ncase = \"emptying_sloping_profile\"\n\n## Set up\nconfig = Dict{String,Any}()\nid_lsw = 1\nid_out = 2\nid_lsw_end = 3\nids = [id_lsw, id_out, id_lsw_end]\nconfig[\"ids\"] = ids\nconfig[\"update_timestep\"] = 86400.0\nconfig[\"starttime\"] = Date(\"2022-01-01\")\nconfig[\"endtime\"] = Date(\"2022-02-01\")\nconfig[\"state\"] = DataFrame(; id=ids, S=1e6, C=0.1)\nconfig[\"static\"] = DataFrame(; id=[], variable=[], value=[])\nconfig[\"forcing\"] = DataFrame(; time=DateTime[], variable=Symbol[], id=Int[], value=Float64[])\nconfig[\"node\"] = DataFrame(; id=ids, node=[\"LSW\", \"OutflowTable\", \"LSW\"])\nconfig[\"edge\"] = Ribasim.edgepairs([\n    (id_lsw, \"LSW\", \"x\") => (id_out, \"OutflowTable\", \"a\"),\n    (id_lsw, \"LSW\", \"s\") => (id_out, \"OutflowTable\", \"s\"),\n    (id_out, \"OutflowTable\", \"b\") => (id_lsw_end, \"LSW\", \"x\"),\n])\nconfig[\"profile\"] = Ribasim.profilesets(;\n    ids, volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n## Simulate\nreg = Ribasim.run(config)\n\n## Plot results\nplot_series(reg, id_lsw)\n\n\n\n\n\n\n\nCode\ncase = \"emptying_steep_profile_Hupsel\"\n\n## Set up\nconfig = Dict{String,Any}()\nid_lsw = 1\nid_out = 2\nid_lsw_end = 3\nids = [id_lsw, id_out, id_lsw_end]\nconfig[\"ids\"] = ids\nconfig[\"update_timestep\"] = 86400.0\nconfig[\"starttime\"] = Date(\"2022-01-01\")\nconfig[\"endtime\"] = Date(\"2022-02-01\")\nconfig[\"state\"] = DataFrame(; id=ids, S=1e6, C=0.1)\nconfig[\"static\"] = DataFrame(; id=[], variable=[], value=[])\nconfig[\"forcing\"] = DataFrame(; time=DateTime[], variable=Symbol[], id=Int[], value=Float64[])\nconfig[\"node\"] = DataFrame(; id=ids, node=[\"LSW\", \"OutflowTable\", \"LSW\"])\nconfig[\"edge\"] = Ribasim.edgepairs([\n    (id_lsw, \"LSW\", \"x\") => (id_out, \"OutflowTable\", \"a\"),\n    (id_lsw, \"LSW\", \"s\") => (id_out, \"OutflowTable\", \"s\"),\n    (id_out, \"OutflowTable\", \"b\") => (id_lsw_end, \"LSW\", \"x\"),\n])\nconfig[\"profile\"] = Ribasim.profilesets(;\n    ids,\n    volume=[0.0, 7427.69, 14855.39, 750197.37],\n    area=[92152.28, 92152.28, 92152.28, 92152.28],\n    discharge=[0.0, 0.0, 0.096, 9.60],\n    level=[18.90, 19.10, 19.30, 39.10])\n\n## Simulate\nreg = Ribasim.run(config)\n\n## Plot results\nplot_series(reg, id_lsw)"
  },
  {
    "objectID": "demo.html#precipitation-forcing",
    "href": "demo.html#precipitation-forcing",
    "title": "Ribasim",
    "section": "2.2 Precipitation forcing",
    "text": "2.2 Precipitation forcing\nThis fictional free flowing LSW is simulated with only the external forcing of synthetic precipitation data. The storage and the outflow respond to the preciptation as shown below.\n\n\nCode\ncase = \"precipitation\"\n\n## Set up\nconfig = Dict{String,Any}()\nid_lsw = 1\nid_out = 2\nid_lsw_end = 3\nids = [id_lsw, id_out, id_lsw_end]\nconfig[\"ids\"] = ids\nconfig[\"update_timestep\"] = 86400.0\nconfig[\"starttime\"] = Date(\"2019-01-01\")\nconfig[\"endtime\"] = Date(\"2020-01-01\")\nconfig[\"state\"] = DataFrame(; id=ids, S=1e6, C=0.1)\nconfig[\"static\"] = DataFrame(; id=[], variable=[], value=[])\nconfig[\"forcing\"] = @subset(lswforcing, :variable == \"P\", :id == 1)\nconfig[\"node\"] = DataFrame(; id=ids, node=[\"LSW\", \"OutflowTable\", \"LSW\"])\nconfig[\"edge\"] = Ribasim.edgepairs([\n    (id_lsw, \"LSW\", \"x\") => (id_out, \"OutflowTable\", \"a\"),\n    (id_lsw, \"LSW\", \"s\") => (id_out, \"OutflowTable\", \"s\"),\n    (id_out, \"OutflowTable\", \"b\") => (id_lsw_end, \"LSW\", \"x\"),\n])\nconfig[\"profile\"] = Ribasim.profilesets(;\n    ids, volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n# Simulate\nreg = Ribasim.run(config)\n\n# Plot results\nplot_series(reg, id_lsw)"
  },
  {
    "objectID": "demo.html#evaporation-forcing",
    "href": "demo.html#evaporation-forcing",
    "title": "Ribasim",
    "section": "2.3 Evaporation forcing",
    "text": "2.3 Evaporation forcing\nThe LSW loses water from evaporation. Outflow occurs according to the relation as in Section 2.1, but overall volume decline is faster rate due to additional loss from evaporation. Evaporation does not occur in an empty LSW.\nThe second example shows the LSW with no simulated discharge, so that the only output is evaporation\n\n\nCode\ncase = \"evaporation\"\n\n## Set up\nconfig = Dict{String,Any}()\nid_lsw = 1\nid_out = 2\nid_lsw_end = 3\nids = [id_lsw, id_out, id_lsw_end]\nconfig[\"ids\"] = ids\nconfig[\"update_timestep\"] = 86400.0\nconfig[\"starttime\"] = Date(\"2019-01-01\")\nconfig[\"endtime\"] = Date(\"2019-06-01\")\nconfig[\"state\"] = DataFrame(; id=ids, S=1e6, C=0.1)\nconfig[\"static\"] = DataFrame(; id=[], variable=[], value=[])\nconfig[\"forcing\"] = @subset(lswforcing, :variable == \"E_pot\", :id == 1)\nconfig[\"node\"] = DataFrame(; id=ids, node=[\"LSW\", \"OutflowTable\", \"LSW\"])\nconfig[\"edge\"] = Ribasim.edgepairs([\n    (id_lsw, \"LSW\", \"x\") => (id_out, \"OutflowTable\", \"a\"),\n    (id_lsw, \"LSW\", \"s\") => (id_out, \"OutflowTable\", \"s\"),\n    (id_out, \"OutflowTable\", \"b\") => (id_lsw_end, \"LSW\", \"x\"),\n])\nconfig[\"profile\"] = Ribasim.profilesets(;\n    ids, volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n## Simulate\nreg = Ribasim.run(config)\n\n## Plot results\nplot_series(reg, id_lsw)\n\n\n\n\n\n\n\nCode\ncase = \"evaporation2\"\n\n## Set up\nconfig = Dict{String,Any}()\nid_lsw = 1\nid_bnd = 2\nids = [id_lsw, id_bnd]\nconfig[\"ids\"] = ids\nconfig[\"update_timestep\"] = 86400.0\nconfig[\"starttime\"] = Date(\"2019-01-01\")\nconfig[\"endtime\"] = Date(\"2020-01-01\")\nconfig[\"state\"] = DataFrame(; id=ids, S=1e6, C=0.1)\nconfig[\"static\"] = DataFrame(; id=[], variable=[], value=[])\nconfig[\"forcing\"] = @subset(lswforcing, :variable == \"E_pot\", :id == 1)\nconfig[\"node\"] = DataFrame(; id=ids, node=[\"LSW\", \"NoFlowBoundary\"])\nconfig[\"edge\"] = Ribasim.edgepairs([\n    (id_lsw, \"LSW\", \"x\") => (id_bnd, \"NoFlowBoundary\", \"x\"),\n])\nconfig[\"profile\"] = Ribasim.profilesets(;\n    ids=[1], volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n## Simulate\nreg = Ribasim.run(config)\n\n## Plot results\nplot_series(reg, id_lsw)"
  },
  {
    "objectID": "demo.html#evaporation-and-precipitation-forcings",
    "href": "demo.html#evaporation-and-precipitation-forcings",
    "title": "Ribasim",
    "section": "2.4 Evaporation and precipitation forcings",
    "text": "2.4 Evaporation and precipitation forcings\nThis example shows the evaporation and precipitation flux simulated together.\n\n\nCode\ncase = \"evaporation_precipitation\"\n\n## Set up\nconfig = Dict{String,Any}()\nid_lsw = 1\nid_bnd = 2\nids = [id_lsw, id_bnd]\nconfig[\"ids\"] = ids\nconfig[\"update_timestep\"] = 86400.0\nconfig[\"starttime\"] = Date(\"2019-01-01\")\nconfig[\"endtime\"] = Date(\"2020-01-01\")\nconfig[\"state\"] = DataFrame(; id=ids, S=1e6, C=0.1)\nconfig[\"static\"] = DataFrame(; id=[], variable=[], value=[])\nconfig[\"forcing\"] = @subset(lswforcing, :variable in [\"P\", \"E_pot\"], :id == 1)\nconfig[\"node\"] = DataFrame(; id=ids, node=[\"LSW\", \"NoFlowBoundary\"])\nconfig[\"edge\"] = Ribasim.edgepairs([\n    (id_lsw, \"LSW\", \"x\") => (id_bnd, \"NoFlowBoundary\", \"x\"),\n])\nconfig[\"profile\"] = Ribasim.profilesets(;\n    ids=[1], volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n## Simulate\nreg = Ribasim.run(config)\n\n## Plot\nplot_series(reg, id_lsw)"
  },
  {
    "objectID": "demo.html#infiltration",
    "href": "demo.html#infiltration",
    "title": "Ribasim",
    "section": "2.5 Infiltration",
    "text": "2.5 Infiltration\nInfiltration is an out flux of the LSW. This example shows the LSW storage responding to an enhanced forcing of infiltration. There is no outflow simulated of this LSW, so that the only output is the infiltration.\n\n\nCode\ncase = \"Infiltration\"\n\n## Set up\nconfig = Dict{String,Any}()\nid_lsw = 1\nid_bnd = 2\nids = [id_lsw, id_bnd]\nconfig[\"ids\"] = ids\nconfig[\"update_timestep\"] = 86400.0\nconfig[\"starttime\"] = Date(\"2019-01-01\")\nconfig[\"endtime\"] = Date(\"2019-02-01\")\nconfig[\"state\"] = DataFrame(; id=ids, S=1e6, C=0.1)\nconfig[\"static\"] = DataFrame(; id=[id_lsw], variable=[\"infiltration\"], value=[1.5e-1])\nconfig[\"forcing\"] = lswforcing[1:0, :]  # no forcing\nconfig[\"node\"] = DataFrame(; id=ids, node=[\"LSW\", \"NoFlowBoundary\"])\nconfig[\"edge\"] = Ribasim.edgepairs([\n    (id_lsw, \"LSW\", \"x\") => (id_bnd, \"NoFlowBoundary\", \"x\"),\n])\nconfig[\"profile\"] = Ribasim.profilesets(;\n    ids=[id_lsw], volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n## Simulate\nreg = Ribasim.run(config)\n\n## Plot results\nplot_series(reg, id_lsw)"
  },
  {
    "objectID": "demo.html#urban-runoff",
    "href": "demo.html#urban-runoff",
    "title": "Ribasim",
    "section": "2.6 Urban Runoff",
    "text": "2.6 Urban Runoff\nUrban runoff is a surface water input to the LSW. In case of the Netherlands, this is not calculated by MODFLOW but by the unsaturated zone model MetaSWAP. This example shows the LSW storage responding to the influx forcing of urban runoff.\n\n\nCode\ncase = \"Urban Runoff\"\n\n## Set up\nconfig = Dict{String,Any}()\nid_lsw = 1\nid_bnd = 2\nids = [id_lsw, id_bnd]\nconfig[\"ids\"] = ids\nconfig[\"update_timestep\"] = 86400.0\nconfig[\"starttime\"] = Date(\"2019-01-01\")\nconfig[\"endtime\"] = Date(\"2019-06-01\")\nconfig[\"state\"] = DataFrame(; id=ids, S=1e6, C=0.1)\nconfig[\"static\"] = DataFrame(; id=[], variable=[], value=[])\nconfig[\"forcing\"] = @subset(lswforcing, :variable == \"urban_runoff\", :id == 1)\nconfig[\"node\"] = DataFrame(; id=ids, node=[\"LSW\", \"NoFlowBoundary\"])\nconfig[\"edge\"] = Ribasim.edgepairs([\n    (id_lsw, \"LSW\", \"x\") => (id_bnd, \"NoFlowBoundary\", \"x\"),\n])\nconfig[\"profile\"] = Ribasim.profilesets(;\n    ids=[id_lsw], volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n## Simulate\nreg = Ribasim.run(config)\n\n## Plot\nplot_series(reg, id_lsw)"
  },
  {
    "objectID": "demo.html#allocation-to-multiple-users-agriculture-and-industry",
    "href": "demo.html#allocation-to-multiple-users-agriculture-and-industry",
    "title": "Ribasim",
    "section": "2.7 Allocation to multiple users (agriculture and industry)",
    "text": "2.7 Allocation to multiple users (agriculture and industry)\nThe allocation is based upon demand and prioritisation of the users and the available water in the LSW. In a free flowing LSW only water from the LSW can be abstracted by the users: agriculture and industry. In this example there are two users. Agriculture has higher prioirty than industry, therefore when there is a shortage of available water, agriculture abstracts water before industry as demonstrated.\nWhen water supply is limited, the model follows “de verdringingsreeks” (water prioritization rules in times of water shortage in the Netherlands)."
  },
  {
    "objectID": "demo.html#sec-free-balance",
    "href": "demo.html#sec-free-balance",
    "title": "Ribasim",
    "section": "2.8 Water balance of a single LSW (Hupsel)",
    "text": "2.8 Water balance of a single LSW (Hupsel)\nThis simulation is for the LSW Hupsel. The LSW is a free flowing LSW."
  },
  {
    "objectID": "demo.html#sec-free-comparison",
    "href": "demo.html#sec-free-comparison",
    "title": "Ribasim",
    "section": "2.9 Water balance comparison Hupsel",
    "text": "2.9 Water balance comparison Hupsel\nThe following two figures show Hupsel LSW water balance for the Ribasim prototype compared to the water balance simulated by Mozart, the precursor to Ribasim. The figures show a good agreement between the two simulations."
  },
  {
    "objectID": "demo.html#bifurcation",
    "href": "demo.html#bifurcation",
    "title": "Ribasim",
    "section": "2.10 Bifurcation",
    "text": "2.10 Bifurcation\nTo handle bifurcations, we want to be able to model them using an adjustable fraction. To implement this we use a separate Bifurcation node, that has an inflow src, and outflows dst_1 and dst_2. In this example dst_1 will receive 33% of the flow, and dst_2 will receive 67%. An error is raised if the fractions do not add up to 100%.\n\n\nCode\ncase = \"Bifurcation\"\n\n## Set up\nconfig = Dict{String,Any}()\nid_lsw = 1\nid_out = 2\nid_bif = 3\nid_end1 = 4\nid_end2 = 5\nids = [id_lsw, id_out, id_bif, id_end1, id_end2]\nconfig[\"ids\"] = ids\nconfig[\"update_timestep\"] = 86400.0\nconfig[\"starttime\"] = DateTime(\"2022-01-01\")\nconfig[\"endtime\"] = DateTime(\"2022-02-01\")\nconfig[\"state\"] = DataFrame(id=ids, S=1e6, C=0.1)\nconfig[\"static\"] = DataFrame(; id=id_bif, variable=[\"fraction_1\", \"fraction_2\"], value=[0.33, 0.67])\nconfig[\"forcing\"] = DataFrame(; time=DateTime[], variable=Symbol[], id=Int[], value=Float64[])\nconfig[\"node\"] = DataFrame(; id=ids, node=[\"LSW\", \"OutflowTable\", \"Bifurcation\", \"LSW\", \"LSW\"])\nconfig[\"edge\"] = Ribasim.edgepairs([\n    (id_lsw, \"LSW\", \"x\") => (id_out, \"OutflowTable\", \"a\"),\n    (id_lsw, \"LSW\", \"s\") => (id_out, \"OutflowTable\", \"s\"),\n    (id_out, \"OutflowTable\", \"b\") => (id_bif, \"Bifurcation\", \"src\"),\n    (id_bif, \"Bifurcation\", \"dst_1\") => (id_end1, \"LSW\", \"x\"),\n    (id_bif, \"Bifurcation\", \"dst_2\") => (id_end2, \"LSW\", \"x\"),\n])\nconfig[\"profile\"] = Ribasim.profilesets(;\n    ids, volume=[0.0, 1e6], area=[1e6, 1e6],\n    discharge=[0.0, 1e0], level=[10.0, 11.0])\n\n## Simulate\nreg = Ribasim.run(config)\n\n## Plot results\nfig = Figure()\nylabel = \"flow rate / m³ s⁻¹\"\ntimespan = datetime2unix(config[\"starttime\"]) .. datetime2unix(config[\"endtime\"])\nax = time!(Axis(fig[1, 1]; ylabel), timespan.left, timespan.right)\n\nname = Symbol(:bifurcation_, 3)\nlines!(ax, timespan, interpolator(reg, Symbol(name, :₊src₊Q)), label=\"bifurcation inflow\")\nlines!(ax, timespan, interpolator(reg, Symbol(name, :₊dst_1₊Q)), label=\"bifurcation outflow 1\")\nlines!(ax, timespan, interpolator(reg, Symbol(name, :₊dst_2₊Q)), label=\"bifurcation outflow 2\")\nfig[1, 2] = Legend(fig, ax, \"\", framevisible=true)\nhidexdecorations!(ax, grid=false)\nfig"
  },
  {
    "objectID": "demo.html#single-level-controlled-lsw-tol",
    "href": "demo.html#single-level-controlled-lsw-tol",
    "title": "Ribasim",
    "section": "3.1 Single Level Controlled LSW (Tol)",
    "text": "3.1 Single Level Controlled LSW (Tol)\nThis simulation is for the LSW De Tol. The LSW is a level controlled meaning that water is allocated to maintain water levels at a target level."
  },
  {
    "objectID": "demo.html#de-tol-water-balance-comparison-with-mozart",
    "href": "demo.html#de-tol-water-balance-comparison-with-mozart",
    "title": "Ribasim",
    "section": "3.2 De Tol water balance comparison with Mozart",
    "text": "3.2 De Tol water balance comparison with Mozart\nThe following two figures show De Tol LSW water balance for the Ribasim prototype compared to the water balance simulated by Mozart, the precursor to Ribasim. The figures show a good agreement between the two simulations"
  },
  {
    "objectID": "equations.html",
    "href": "equations.html",
    "title": "Water balance",
    "section": "",
    "text": "Ribasim currently simulates the following “natural” water balance terms:\nAdditionally, Ribasim simulates the following “allocated” water balance terms:\nDepending on the type of boundary conditions, Ribasim requires relation between storage volume and wetted area (\\(A\\)), and between the storage volume and the water level (\\(h\\)). These are (currently) represented by piecewise linear relationships."
  },
  {
    "objectID": "equations.html#precipitation",
    "href": "equations.html#precipitation",
    "title": "Water balance",
    "section": "1.1 Precipitation",
    "text": "1.1 Precipitation\nThe precipitation term is given by:\n\\[\nQ_P = P A(S)\n\\]\nWhere \\(P\\) is the precipitation rate and \\(A\\) is the wetted area. \\(A\\) is a function of storage: as the volume of water changes, the area of the free water surface may change as well, depending on the slopes of the surface waters."
  },
  {
    "objectID": "equations.html#evaporation",
    "href": "equations.html#evaporation",
    "title": "Water balance",
    "section": "1.2 Evaporation",
    "text": "1.2 Evaporation\nThe evaporation term is given by:\n\\[\nQ_E = E_{pot} \\cdot A(S) \\cdot (0.5 \\cdot \\tanh(S - 50.0) / 10.0) + 0.5\n\\]\nWhere \\(E_{pot}\\) is the potential evaporation rate and \\(A\\) is the wetted area. The \\((0.5 \\cdot \\tanh(S - 50.0) / 10.0) + 0.5\\) term ensures no evaporation occurs when \\(S <= 0\\) and is a sigmoid function which provides a smooth gradient as \\(S \\rightarrow 0\\).\nA straightforward formulation \\(Q_E = \\mathrm{max}(E_{pot} A(S), 0)\\) is unsuitable, as \\(\\frac{\\mathrm{d}Q_E}{\\mathrm{d}S}(S=0)\\) is \\(\\infty\\). A hyperbolic tangent is a commonly used activation function (Wikipedia contributors 2022) to approximate on-off behavior while preserving a smooth derivative.\nA non-smooth derivative results in extremely small timesteps and long computation time: ModelingToolkit identifies the singular behavior and adjusts it timestepping. In a physical interpretation, evaporation is switched on or off per individual droplet of water. In general, the effect of the sigmoid term is negligible, or not even necessary. As a surface water dries, its wetted area decreases and so does the evaporative flux. However, for (simplified) cases with constant wetted surface (a rectangular profile), evaporation only stops at \\(S = 0\\)."
  },
  {
    "objectID": "equations.html#infiltration-and-drainage",
    "href": "equations.html#infiltration-and-drainage",
    "title": "Water balance",
    "section": "1.3 Infiltration and Drainage",
    "text": "1.3 Infiltration and Drainage\nInfiltration is provided as a lump sum for the basin. If Ribasim is coupled with MODFLOW 6, the infiltration is computed as the sum of all positive flows of the MODFLOW 6 boundary conditions in the basin:\n\\[\nQ_{inf} = \\sum_{i=1}^{n} \\sum_{j=1}^{m} \\max(Q_{\\mathrm{mf6}_{i,j}}, 0.0)\n\\]\nWhere \\(i\\) is the index of the boundary condition, \\(j\\) the MODFLOW 6 cell index, \\(n\\) the number of boundary conditions, and \\(m\\) the number of MODFLOW 6 cells in the basin. \\(Q_{\\mathrm{mf6}_{i,j}}\\) is the flow computed by MODFLOW 6 for cell \\(j\\) for boundary condition \\(i\\).\nDrainage is a lump sump for the basin, and consists of the sum of the absolute value of all negative flows of the MODFLOW 6 boundary conditions in the basin.\n\\[\nQ_{drn} = \\sum_{i=1}^{n} \\sum_{j=1}^{m} \\left| \\min(Q_{\\mathrm{mf6}_{i,j}}, 0.0) \\right|\n\\]\nThe interaction with MODFLOW 6 boundary conditions is explained in greater detail in the the MODFLOW coupling section of this documentation."
  },
  {
    "objectID": "equations.html#upstream-and-downstream-flow",
    "href": "equations.html#upstream-and-downstream-flow",
    "title": "Water balance",
    "section": "1.4 Upstream and downstream flow",
    "text": "1.4 Upstream and downstream flow\nRibasim’s basins can be connected to each other, and each basin expects an explicit connection. Two connections are currently available for inter-basin flows:\n\nOutflowTable\nLevelLink\n\nThe flow direction of the basin is not pre-determined: flow directions may freely reverse, provided the connection allows it. Currently, a LevelLink allows bidirectional flow, but the\nAdditionally, two additional “connections” area available for the “outmost” basins (external nodes) in a network.\n\nNoFlowBoundary\nHeadBoundary\n\n\n1.4.1 OutflowTable\nThe OutflowTable is a tabulation of a basin’s discharge behavior. It describes a piecewise linear relationship between the basin’s storage volume and its discharge. It can be understood as an emprical description of a basin’s properties. This can include a weir, but also the lumped hydraulic behavior of the upstream channels.\nThe OutflowTable should indicate at which volume no discharge occurs (the dead storage volume).\n\n\n\n\n\n\nNote\n\n\n\nCurrently, the discharge relies only on the basin’s volume; it could also use the volume of both connected basins to simulate backwater effects, submersion of weirs, or even reversal of flows for high precipitation events.\n\n\n\n\n1.4.2 LevelLink\nA LevelLink connects two basins together. The flow between the two basins is determined by a linear relationship:\n\\[\nQ = C (h_a - h_b)\n\\]\nWhere \\(h_a\\) is the water level in the first basin, \\(h_b\\) is the water level in the second basin, and \\(C\\) is the conductance of the link. A LevelLink makes no assumptions about the direction of the flow: water flows from high to low.\n\n\n1.4.3 NoFlowBoundary\nThis sets the exchange flow to 0.\n\n\n1.4.4 HeadBoundary\nThis sets the water level in the basin to a fixed level; lower or higher level result in instantaneous corrective fluxes."
  },
  {
    "objectID": "equations.html#general-user",
    "href": "equations.html#general-user",
    "title": "Water balance",
    "section": "2.1 General User",
    "text": "2.1 General User\nThe General User category include the users Agriculture, Industry and Public Water supply. These users extract water from the basin and the demand (\\(\\demuser\\)) is determined externally. The source of water allocated to the General User is dependent on if the basin is a free-flowing type basin or a level-controlled basin.\nIf the basin is free-flowing, the water source will be the available water within the basin. If the basin is level-controlled additional water can be sourced from the regional network, should the water available from the basin be insufficient to satisfy \\(\\demuser\\).\nThe availability of water (\\(\\qavail\\)) internally in a basin in a given timestep is calculated by Equation 1. This volume is available to be extracted by the General Users. In the Ribasim prototype, additional water from the regional network is currently modelled as an unlimited supply.\n\\[\n\\qavail = \\frac{(P - E_{pot}) \\cdot \\mathit{area}}{\\mathrm{Δ}t} - \\min(0, Q_{infil} - Q_{drain} - Q_{runoff})\n\\tag{1}\\]\nThe \\(\\qavail\\) can be assigned to multiple users in the same basin. Allocation is based upon user priority. For a given user, in the case where \\(\\qavail > \\demuser\\), the user demand is satisfied and the remaining \\(\\qavail\\) becomes available for the user of next highest priority. For a given user, in the case where \\(\\demuser > \\qavail\\) then all of the available water is assigned to the user. This results in an allocation shortage and no remaining local water for any users of lower priority.\nHowever, as discussed, if the basin is a level-controlled basin, additional water can then be sourced from the regional network and is allocated to satisfy the allocation shortage of the General User.\nThe allocation of water is decided intermittently by a separate process. This separate process is not all-knowing and it may overextract. Like other water balance sinks, negative storage is avoided and smooth numerical behavior is ensured via an activation function:\n\\[\nQ_{user} = Q_{alloc} \\cdot (0.5 \\cdot \\tanh(S - 50.0) / 10.0) + 0.5\n\\]"
  },
  {
    "objectID": "equations.html#level-control",
    "href": "equations.html#level-control",
    "title": "Water balance",
    "section": "2.2 Level Control",
    "text": "2.2 Level Control\nA level-controlled basin (local_surface_water_type = \"P\") has a user demand referred to as water management (\\(\\demwm\\)). The purpose of this demand is to maintain the water levels for each basin at a target level. This target levels is determined externally. The \\(\\demwm\\) is negative if additional water is required to increase the water level in the basin, or positive if there is surplus water which must be removed to lower the level in the basin. When \\(\\demwm\\) is positive and there is surplus water, Ribasim is designed to make any surplus water available to General Users within the basin for abstraction. This is modelled by adding the \\(\\demwm\\) to the \\(\\qavail\\) in calculated in Equation 2.\n\\[\n\\qavail = \\demwm\n\\tag{2}\\]\nWhen the \\(\\demwm\\) is negative, the \\(\\demwm\\) is allocated first from the basin \\(\\qavail\\), and then secondly with water from the national network, should the local basin water not be sufficient to satisfy \\(\\demwm\\). This demand is therefore handled similar to that of a General User. In the case that a General User is allocated water as a higher priority than the Level Control such that the water level of the basin decreases, the \\(\\demwm\\) will increase accordingly. However, in most cases the demand for Level Control is higher than that of the General Users so this does not occur."
  },
  {
    "objectID": "equations.html#flushing",
    "href": "equations.html#flushing",
    "title": "Water balance",
    "section": "2.3 Flushing",
    "text": "2.3 Flushing\nThe flushing requirement for the basin is a special case of user. Flushing is required to maintain water quality in the basin. This is determined externally. Water from the national network flows into the basin, and the same volume gets removed from the basin back to the national network. This water cannot be allocated to other users and there is no net change to the water level in the basin or the \\(\\qavail\\), see Equation 3.\n\\[\n\\mathit{Q_{in}} = -\\mathit{Q_{out}}\n\\tag{3}\\]"
  },
  {
    "objectID": "coupling-demo.html",
    "href": "coupling-demo.html",
    "title": "Ribasim-MODFLOW 6 Demonstration",
    "section": "",
    "text": "In our test cases, we will work with the Dutch national groundwater model (LHM). For testing, we simplify the top boundary conditions to just three surface water “systems”, from large to small:\n\nPrimary\nSecondary\nTertiary\n\nThese systems are separated in the groundwater model schematization due to the relatively small size of the surface waters (several meters in width) in comparison with relatively coarse cells of the groundwater model (250 m): most cells in the LHM contain more than one surface water, and are included via representative parameters which take the physical scaling into account. In case of sufficiently small cell sizes, no overlap occurs and all surface waters can be represented in a single grid.\nRibasim has no knowledge of these systems unless explicitly separated into different (sub-)basins. In the examples below, these three systems are represented by one basin with a single volume. For the purposes of testing, we have not yet created empirical volume-level relationships for the surface water of every cell extracted from a hydraulic model. Instead, we have chosen an (over)simplified parametrization of the hydraulic properties, which makes it easy to verify the behavior of Ribasim and the coupling procedures:\n\nPrimary, secondary, and tertiary systems have a rectangular profile: the area of the surface water does not change with water level or volume.\nWater depth is constant for a system within a basin.\nWater depth increases linearly with volume. (This follows from 1.)\nWater depth is distributed across the systems in a geometric progression: when the tertiary system contains 0.1 m of water, the secondary system contains 0.2 m, and the primary system contains 0.4 m.\nWater depth is 0.0 m for all systems when basin volume is 0.0. (This follows from 4.)\nThe distribution of water occurs according to the surface water area (width times length) used for the LHM parametrization of river bed conductance.\n\nFor freely draining basins, a simplified storage-discharge relationship has been derived as follows:\n\nThe area of the basin polygon has been multiplied by 1 mm/d (roughly the average precipitation excess in the Netherlands). This yields a “normative discharge”.\nA corresponding normative volume has been chosen, corresponding with water depths of 0.4, 0.2, and 0.1 m for the primary, secondary, and tertiary surface waters respectively.\nA dead storage volume has been chosen, corresponding with water depths of 0.2, 0.1, and 0.05 m for the primary, secondary, and tertiary surface waters respectively. The basin only starts discharging when the storage volume exceeds this value.\n\n\n\n\n\n\n\nNote\n\n\n\nRibasim is not limited to such oversimplified parametrization! Ribasim uses tabulations and therefore supports arbitrary (piecewise linear) volume-depth and volume-discharge relationships.\n\n\nA visual representation of this simplified conceptual schematization is given in Figure 1 and Figure 2.\n\n\n\nFigure 1: Distribution of water depths over the primary, secondary, and tertiary system.\n\n\n\n\n\nFigure 2: Discharge as a function of basin storage volume.\n\n\nAn example of the resulting parameters for a single cell is shown in Table 1. The first row shows the water levels when the basin is empty. The level for primary, secondary, and tertiary are equal to the bottom elevation of the surface waters. The second row shows the volume and levels for water depths of 0.4, 0.2, and 0.1 m. The third row shows the volume and levels for a tenfold larger volume. This results in implausible water levels with depths of 4.0, 2.0 and 1.0 m; the water level in the primary system is over two meters higher than in the tertiary system. In reality, the surface waters would overflow and surface ponding would occur; this mechanism is ignored in the test cases for the sake of simplicity.\n\n\nTable 1: Volume-level table for a single cell in the Hupsel basin.\n\n\nVolume (m3)\nPrimary (m NAP)\nSecondary (m NAP)\nTertiary (m NAP)\n\n\n\n\n0.0\n25.65\n25.83\n26.60\n\n\n6843.1\n26.05\n26.03\n26.70\n\n\n68431.0\n29.65\n27.83\n27.60\n\n\n\n\nFigure 3 shows the volume of the first row of the cell based input for the primary system. Symbology is set to unique values. While water levels differ per cell in this parametrization, the “normative volume” defined above is shared by all cells in a basin.\n\n\n\nFigure 3: Basin normative volume of the primary system.\n\n\nFigure 3 shows the water level corresponding to the normative storage volume based input for the primary system (it corresponds to the value shown in the first row of the primary colum in Table 1). We see a clear gradient from west to east: as our simplified parametrization assumes a constant water depth for all cells in a single system, water levels spatially fall and rise with the bottom elevation.\n\n\n\nFigure 4: Water level corresponding to the normative basin volume of the primary system."
  },
  {
    "objectID": "coupling-demo.html#example-configuration",
    "href": "coupling-demo.html#example-configuration",
    "title": "Ribasim-MODFLOW 6 Demonstration",
    "section": "2 Example: Configuration",
    "text": "2 Example: Configuration\nAn example of the MODFLOW 6 section of TOML configuration required for a coupled run can be seen below:\n[modflow]\nsimulation = \"../data/hupsel/mfsim.nam\"\nmode = \"sequential\"\ntimestep = 86400.0\n\n[modflow.models]\n\n[modflow.models.gwf]\ntype = \"gwf\"\ndataset = \"../data/volume_level_profile-hupsel.nc\"\nbasins = \"basin_id\"\n\n[[modflow.models.gwf.bounds]]\nriver = \"RIV_P\"\ndrain = \"DRN_P\"\nprofile = \"profile_primary\"\n\n[[modflow.models.gwf.bounds]]\nriver = \"RIV_S\"\ndrain = \"DRN_S\"\nprofile = \"profile_secondary\"\n\n[[modflow.models.gwf.bounds]]\ndrain = \"DRN_T\"\nprofile = \"profile_tertiary\"\nThe section starts by stating the path to the MODFLOW 6 simulation name file (simulation). The next section contains the information regarding the MODFLOW 6 model(s) to couple to Ribasim’s basins. Per model, a path to the coupling parameter dataset is provided (dataset), along with the variable to use as the basin identification number (basins). Next, for every boundary condition that should be coupled to Ribasim, the package names (river, drain) used by MODFLOW 6 must be specified (as we look for these names in the MODFLOW 6 memory), along with the name of the variable in the coupling dataset which provides the volume-level relationship (profile).\nAs can be seen in the example, the coupling mechanism supports coupling of:\n\nA single drainage package (drain entry).\nA single river package (river entry).\nA combination of river and drainage package (when infiltration conductance does not equal drainage conductance) both (river and drain entry)."
  },
  {
    "objectID": "coupling-demo.html#test-case-hupsel",
    "href": "coupling-demo.html#test-case-hupsel",
    "title": "Ribasim-MODFLOW 6 Demonstration",
    "section": "3 Test case: Hupsel",
    "text": "3 Test case: Hupsel\nTo test the coupling, the following simulations have been setup and run:\n\nA standalone MODFLOW 6 run of sequential steady-states (i.e. no storage) with differing groundwater recharge values.\nA coupled run where the MODFLOW 6 stages are updated by the Ribasim coupler process, but without Ribasim. This results in volumes of 0.0, so all MODFLOW 6 water levels are set equal to bed elevation.\nA coupled run where the water levels are updated by Ribasim.\n\nFrom these tests, we expect the following behavior:\n\nDrainage terms should remain largely the same when the water level is lowered in a steady-state: the amount of recharge is fixed, and this is locally drained.\nIn case of negative recharge (evapotranspiration), infiltration occurs in the surface waters. Infiltration should be zero when the basin volume is 0.\n\n\n\n\nFigure 5: Water balance of the MODFLOW 6 boundary conditions for the Hupsel basin for a standalone MODFLOW 6 run. The four sequential steady states (01, 02, 03, 04) use net groundwater recharge values of 1.0, 0.5, -0.05 and -0.1 mm/d.\n\n\nFigure 5 shows the water balance of steady-state for submodel of the LHM that has been by selecting the cells belonging to the district containing the Hupsel catch, the Berkel.\nThe Hupsel basin show the expected behavior: for a net groundwater recharge of 1.0 mm/d, most is precipitation with a minor part lateral inflow from higher areas. In terms of outgoing flows, most of the precipitation ends up in the surface water, primarily in the many ditches of the tertiary system. Only a relatively small part of the water leaves the basin via the groundwater. Interbasin flows through the groundwater form such a minor role, as the aquifer is thin and transmissivity is limited.\nReducing groundwater recharge to 0.5 mm/d reduces all flows, with the tertiary system playing a less dominant role, relatively speaking: as its elevation is the highest compared to the primary and secondary system, the head difference is reduced strongest for the tertiary system.\nWith evapotranspiration (ET) excess (-0.05 and 0.1 mm/d; low values are chosen here since most ET would be drawn from storage, which is not available in a steady-state model), the surface waters provide mostly inflow, and recharge is a negative term. In this case, the secondary system provides a small amount of infiltration; most of the water is drawn from the surroundings instead.\n\n\n\nFigure 6: Water balance of the MODFLOW 6 boundary conditions for the Hupsel basin for a zero volume run. The four sequential steady states (01, 02, 03, 04) use net groundwater recharge values of 1.0, 0.5, -0.05 and -0.1 mm/d.\n\n\nFigure 6 shows the same model, with 0-basin volume which causes water levels to be set equal to bed elevation. Consequently, primary and secondary outflow terms are larger for positive groundwater recharge as they drain at a lower level and intercept the water before the tertiary system does. Secondly, with negative groundwater recharge, no infiltration occurs and the water is drawn from the surroundings instead. This shows the coupling mechanism adjusting MODFLOW 6 water levels succesfully."
  },
  {
    "objectID": "coupling-demo.html#test-case-de-tol",
    "href": "coupling-demo.html#test-case-de-tol",
    "title": "Ribasim-MODFLOW 6 Demonstration",
    "section": "4 Test case: de Tol",
    "text": "4 Test case: de Tol\nTo test the coupling, the following simulations have been setup and run:\n\nA standalone MODFLOW 6 run of sequential steady-states (i.e. no storage) with differing groundwater recharge values.\nA coupled run where the MODFLOW 6 stages are updated by the Ribasim coupler process, but without Ribasim. This results in volumes of 0.0, so all MODFLOW 6 water levels are set equal to bed elevation.\nA coupled run where the water levels are updated by Ribasim.\n\n\n\n\nFigure 7: Water balance of the MODFLOW 6 boundary conditions for De Tol basin for a standalone MODFLOW 6 run. The four sequential steady states (01, 02, 03, 04) use net groundwater recharge values of 1.0, 0.5, -0.05 and -0.1 mm/d.\n\n\nFigure 7 shows the water balance of steady-state for a submodel of the LHM for the Polder de Tol and its surroundings. While groundwater recharge is the dominant ingoing flow, lateral groundwater flow (over the entire depth of the groundwater model) is a sizable inflow for the area; the larger lateral inflow shows that De Tol is a net receiver of groundwater which is mostly discharged through the secondary system. In contrast to the Hupsel, the tertiary system is almost entirely absent: drainage occurs not through ephemeral tertiary ditches, but by the permanently water-bearing ditches of the primary and secondary system. Unlike the Hupsel, the water balance does not shrink to very small discharges, as there is sizable regional groundwater flow.\n\n\n\nFigure 8: Water balance of the MODFLOW 6 boundary conditions for De Tol basin for a zero volume run. The four sequential steady states (01, 02, 03, 04) use net groundwater recharge values of 1.0, 0.5, -0.05 and -0.1 mm/d.\n\n\nFigure 8 shows the same model, with 0-basin volume which causes water levels to be set equal to bed elevation. The total discharge is larger: the primary and secondary systems are set to lower levels, and so the head difference is larger. While De Tol’s evapotranspiration excess can be fed by the regional groundwater, the primary and secondary ditches also provide some part; as expected, they do not feed when the coupling mechanism adjusts MODFLOW 6’s water levels."
  }
]