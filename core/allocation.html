<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Ribasim - Allocation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../core/numerics.html" rel="next">
<link href="../core/equations.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../assets/styles.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="https://user-images.githubusercontent.com/4471859/224825908-bee7e044-bc6b-4561-8b08-5d330cce3ed5.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Ribasim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../core/index.html" rel="" target="" aria-current="page">
 <span class="menu-text">Julia core</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../python/index.html" rel="" target="">
 <span class="menu-text">Python tooling</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../qgis/index.html" rel="" target="">
 <span class="menu-text">QGIS plugin</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../couple/index.html" rel="" target="">
 <span class="menu-text">Coupled models</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../contribute/index.html" rel="" target="">
 <span class="menu-text">Contributing</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Deltares/Ribasim" rel="" target=""><i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../core/allocation.html">Allocation</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../core/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Julia core</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../core/usage.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Usage</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../core/equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Equations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../core/allocation.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Allocation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../core/numerics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Numerical considerations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../build/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">API Reference</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-allocation-problem" id="toc-the-allocation-problem" class="nav-link active" data-scroll-target="#the-allocation-problem"><span class="header-section-number">1</span> The allocation problem</a>
  <ul class="collapse">
  <li><a href="#allocation-problem-input" id="toc-allocation-problem-input" class="nav-link" data-scroll-target="#allocation-problem-input"><span class="header-section-number">1.1</span> Allocation problem input</a>
  <ul class="collapse">
  <li><a href="#the-subnetwork" id="toc-the-subnetwork" class="nav-link" data-scroll-target="#the-subnetwork"><span class="header-section-number">1.1.1</span> The subnetwork</a></li>
  <li><a href="#source-flows" id="toc-source-flows" class="nav-link" data-scroll-target="#source-flows"><span class="header-section-number">1.1.2</span> Source flows</a></li>
  <li><a href="#user-demands" id="toc-user-demands" class="nav-link" data-scroll-target="#user-demands"><span class="header-section-number">1.1.3</span> User demands</a></li>
  <li><a href="#vertical-fluxes-and-local-storage" id="toc-vertical-fluxes-and-local-storage" class="nav-link" data-scroll-target="#vertical-fluxes-and-local-storage"><span class="header-section-number">1.1.4</span> Vertical fluxes and local storage</a></li>
  <li><a href="#flow-magnitude-and-direction-constraints" id="toc-flow-magnitude-and-direction-constraints" class="nav-link" data-scroll-target="#flow-magnitude-and-direction-constraints"><span class="header-section-number">1.1.5</span> Flow magnitude and direction constraints</a></li>
  <li><a href="#fractional-flows-and-user-return-flows" id="toc-fractional-flows-and-user-return-flows" class="nav-link" data-scroll-target="#fractional-flows-and-user-return-flows"><span class="header-section-number">1.1.6</span> Fractional flows and user return flows</a></li>
  </ul></li>
  <li><a href="#the-allocation-optimization-problem" id="toc-the-allocation-optimization-problem" class="nav-link" data-scroll-target="#the-allocation-optimization-problem"><span class="header-section-number">1.2</span> The allocation optimization problem</a>
  <ul class="collapse">
  <li><a href="#the-allocation-graph" id="toc-the-allocation-graph" class="nav-link" data-scroll-target="#the-allocation-graph"><span class="header-section-number">1.2.1</span> The allocation graph</a></li>
  <li><a href="#the-allocation-graph-capacities" id="toc-the-allocation-graph-capacities" class="nav-link" data-scroll-target="#the-allocation-graph-capacities"><span class="header-section-number">1.2.2</span> The allocation graph capacities</a></li>
  <li><a href="#the-optimization-variables" id="toc-the-optimization-variables" class="nav-link" data-scroll-target="#the-optimization-variables"><span class="header-section-number">1.2.3</span> The optimization variables</a></li>
  <li><a href="#the-optimization-objective" id="toc-the-optimization-objective" class="nav-link" data-scroll-target="#the-optimization-objective"><span class="header-section-number">1.2.4</span> The optimization objective</a></li>
  <li><a href="#the-optimization-variable-constraints" id="toc-the-optimization-variable-constraints" class="nav-link" data-scroll-target="#the-optimization-variable-constraints"><span class="header-section-number">1.2.5</span> The optimization variable constraints</a></li>
  </ul></li>
  <li><a href="#final-notes-on-the-allocation-problem" id="toc-final-notes-on-the-allocation-problem" class="nav-link" data-scroll-target="#final-notes-on-the-allocation-problem"><span class="header-section-number">1.3</span> Final notes on the allocation problem</a>
  <ul class="collapse">
  <li><a href="#users-using-their-own-return-flow" id="toc-users-using-their-own-return-flow" class="nav-link" data-scroll-target="#users-using-their-own-return-flow"><span class="header-section-number">1.3.1</span> Users using their own return flow</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#solving-the-allocation-problem" id="toc-solving-the-allocation-problem" class="nav-link" data-scroll-target="#solving-the-allocation-problem"><span class="header-section-number">2</span> Solving the allocation problem</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Allocation</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Allocation is the process of assigning an allocated abstraction flow rate to user nodes in the model based on information about sources, user demands over various priorities, constraints introduced by nodes, local water availability and graph topology. The allocation procedure implemented in Ribasim is heavily inspired by the <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem">maximum flow problem</a>.</p>
<p>The allocation problem is solved per subnetwork of the Ribasim model. The subnetwork is used to formulate an optimization problem with the <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> package, which is solved using the <a href="https://highs.dev/">HiGHS solver</a>. See also the example of solving the maximum flow problem with <code>JuMP.jl</code> <a href="https://jump.dev/JuMP.jl/stable/tutorials/linear/network_flows/#The-max-flow-problem">here</a>.</p>
<section id="the-allocation-problem" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> The allocation problem</h1>
<p>The following data of the parameters and state of a Ribasim model are relevant for the allocation problem.</p>
<section id="allocation-problem-input" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="allocation-problem-input"><span class="header-section-number">1.1</span> Allocation problem input</h2>
<section id="the-subnetwork" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="the-subnetwork"><span class="header-section-number">1.1.1</span> The subnetwork</h3>
<p>The allocation problem is solved per subgraph, where a subgraph is given by a subset <span class="math inline">\(S \subset V\)</span> of node ids. Different subgraphs are disjoint from eachother.</p>
</section>
<section id="source-flows" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="source-flows"><span class="header-section-number">1.1.2</span> Source flows</h3>
<p>Sources are indicated by a set of edges in the subnetwork <span class="math display">\[
E_S^\text{source} \subset \left(S \times S\right) \cap E.
\]</span> That is, if <span class="math inline">\((i,j) \in E_S^\text{source}\)</span>, then <span class="math inline">\(Q_{ij}\)</span> is treated as a source flow in the allocation problem.</p>
</section>
<section id="user-demands" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="user-demands"><span class="header-section-number">1.1.3</span> User demands</h3>
<p>The subnetwork contains a subset of user nodes <span class="math inline">\(U_S \subset S\)</span>, who all have time varying demands over various priorities <span class="math inline">\(p\)</span>: <span class="math display">\[
    d^p_i(t), \quad i \in U_S, p = 1,2,\ldots, p_{\max}.
\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>On this page we assume that the priorities are given by all integers from <span class="math inline">\(1\)</span> to some <span class="math inline">\(p_{\max} \in \mathbb{N}\)</span>. However, in the Ribasim input this is not a requirement; some of these in between priority values can be missing, only the ordering of the given priorities is taken into account.</p>
</div>
</div>
</section>
<section id="vertical-fluxes-and-local-storage" class="level3" data-number="1.1.4">
<h3 data-number="1.1.4" class="anchored" data-anchor-id="vertical-fluxes-and-local-storage"><span class="header-section-number">1.1.4</span> Vertical fluxes and local storage</h3>
<p>Apart from the source flows denoted by edges, there are other sources of water in the subnetwork, associated with the basins in the subnetwork <span class="math inline">\(B_S = B \cap S\)</span>. Firstly there is the sum of the vertical fluxes (precipitation, evaporation, infiltration and drainage) for each basin <span class="math display">\[
    \phi_i(t), \quad \forall i \in B_S.
\]</span></p>
<p>Secondly, there is the available water in each basin above the minimum level <span class="math inline">\(l_{\min,i}\)</span> <span class="math display">\[
    u_i(t)-S(l_{\min,i}), \quad \forall i \in B_S.
\]</span> Note that this value can be negative, which we interpret as a demand from the basin.</p>
</section>
<section id="flow-magnitude-and-direction-constraints" class="level3" data-number="1.1.5">
<h3 data-number="1.1.5" class="anchored" data-anchor-id="flow-magnitude-and-direction-constraints"><span class="header-section-number">1.1.5</span> Flow magnitude and direction constraints</h3>
<p>Nodes in the Ribasim model that have a <code>max_flow_rate</code>, i.e.&nbsp;pumps and outlets, put a constraint on the flow through that node. Some nodes only allow flow in one direction, like pumps, outlets and tabulated rating curves.</p>
</section>
<section id="fractional-flows-and-user-return-flows" class="level3" data-number="1.1.6">
<h3 data-number="1.1.6" class="anchored" data-anchor-id="fractional-flows-and-user-return-flows"><span class="header-section-number">1.1.6</span> Fractional flows and user return flows</h3>
<p>Both fractional flow nodes and user nodes dictate proportional relationships between flows over edges in the subnetwork. Users have a return factor <span class="math inline">\(r_i, i \in U_S\)</span>.</p>
</section>
</section>
<section id="the-allocation-optimization-problem" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="the-allocation-optimization-problem"><span class="header-section-number">1.2</span> The allocation optimization problem</h2>
<section id="the-allocation-graph" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="the-allocation-graph"><span class="header-section-number">1.2.1</span> The allocation graph</h3>
<p>A new graph is created from the subnetwork, which we call the allocation graph. To indicate the difference between subnetwork data and allocation graph data, the allocation graph data is denoted with a hat. The allocation graph consists of:</p>
<ul>
<li>Nodes <span class="math inline">\(\hat{V_S}\)</span>, where each basin, source and user in the subnetwork get a node in the allocation graph. Also nodes that have fractional flow outneighbors get a node in the allocation graph. The implementation makes heavy use of the node id mapping <span class="math inline">\(m_S : i \mapsto \hat{i}\)</span> to translate from subnetwork node IDs to allocation graph node IDs. Unless specified otherwise, we assume this relationship between index symbols that appear both with and without a hat.</li>
<li>Edges <span class="math inline">\(\hat{E_S}\)</span>, where the edges in the allocation graph are given by one or more edges in the subnetwork, where those edges connect nodes in the subnetwork that have an equivalent in the allocation graph. The direction of the edges in the allocation graph is given by the direction constraints in the subnetwork.</li>
</ul>
<p>For notational convenience, we use the notation <span class="math display">\[
    \begin{align}
        \hat{V}^{\text{out}}_S(\hat{i}) = \left\{\hat{j} \in \hat{V}_S : (\hat{i},\hat{j}) \in \hat{E}_S\right\} \\
        \hat{V}^{\text{in}}_S(\hat{j}) = \left\{\hat{i} \in \hat{V}_S : (\hat{i},\hat{j}) \in \hat{E}_S\right\}
    \end{align}
\]</span> for the set of in-neighbors and out-neighbors of a node in the allocation graph respectively.</p>
</section>
<section id="the-allocation-graph-capacities" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="the-allocation-graph-capacities"><span class="header-section-number">1.2.2</span> The allocation graph capacities</h3>
<p>The capacities of the edges of the allocation graph are collected in the sparse capacity matrix <span class="math inline">\(\hat{C}_S \in \overline{\mathbb{R}}_{\ge 0}^{\hat{n}\times\hat{n}}\)</span> where <span class="math inline">\(\hat{n}\)</span> is the number of nodes in the allocation graph. The capacities can be infinite.</p>
<p>The capacities are determined in 3 different ways:</p>
<ul>
<li>If an edge does not exist, i.e.&nbsp;<span class="math inline">\((\hat{i},\hat{j}) \notin \hat{E}\)</span> for certain <span class="math inline">\(1 \le \hat{i},\hat{j}\le \hat{n}\)</span>, then <span class="math inline">\((\hat{C}_S)_{\hat{i},\hat{j}} = 0\)</span>;</li>
<li>The capacity of the edge <span class="math inline">\(\hat{e} \in \hat{E_S}\)</span> is given by the smallest <code>max_flow_rate</code> of the nodes along the equivalent edges in the subnetwork. If there are no nodes with a <code>max_flow_rate</code>, the edge capacity is infinite;</li>
<li>If the edge is a source, the capacity of the edge is given by the flow rate of that source.</li>
</ul>
</section>
<section id="the-optimization-variables" class="level3" data-number="1.2.3">
<h3 data-number="1.2.3" class="anchored" data-anchor-id="the-optimization-variables"><span class="header-section-number">1.2.3</span> The optimization variables</h3>
<p>There are several types of variables whose value has to be determined to solve the allocation problem:</p>
<ul>
<li><p>The flows <span class="math inline">\(F \in \mathbb{R}_{\ge 0}^{\hat{n}\times\hat{n}}\)</span> over the edges in the allocation graph;</p></li>
<li><p>The allocations to the users <span class="math display">\[
  A^\text{user}_{\hat{i},p} \ge 0, \quad \forall \hat{i} \in \hat{U}_S, \forall p \in \{1,2,\ldots, p_\max\},
\]</span> where <span class="math inline">\(\hat{U}_S = m_S(U_S) \subset \hat{V}_S\)</span> is the set of user node ids in the allocation graph;</p></li>
<li><p>The allocations to the basins <span class="math display">\[
  A^\text{basin}_{\hat{i}} \ge 0, \quad \hat{B}_S,
\]</span> where <span class="math inline">\(\hat{B} = m_S(B_S) \subset \hat{V}_S\)</span> is the set of basin node ids in the allocation graph.</p></li>
</ul>
</section>
<section id="the-optimization-objective" class="level3" data-number="1.2.4">
<h3 data-number="1.2.4" class="anchored" data-anchor-id="the-optimization-objective"><span class="header-section-number">1.2.4</span> The optimization objective</h3>
<p>The goal of allocation is to maximize the flow to the users. However, basins can also demand water if their level is below the minimum abstraction level, which we give a higher priority than user demands. Therefore, we use the following optimization objective: <span id="eq-objective"><span class="math display">\[
    \max \sum_{\hat{i} \in \hat{B}_S} A^\text{basin}_{\hat{i}} + \sum_{\hat{i}\in \hat{U}_S} \sum_{p=1}^{p_\max} 2^{-p} A^\text{user}_{\hat{i},p}.
\tag{1}\]</span></span> This is a linear combination of all allocations, where allocations to basins get a weight of <span class="math inline">\(1\)</span> and allocations to users get a weight of <span class="math inline">\(2^{-p}\)</span> where <span class="math inline">\(p\)</span> is the priority.</p>
</section>
<section id="the-optimization-variable-constraints" class="level3" data-number="1.2.5">
<h3 data-number="1.2.5" class="anchored" data-anchor-id="the-optimization-variable-constraints"><span class="header-section-number">1.2.5</span> The optimization variable constraints</h3>
<ul>
<li><p>Source flows: for the source edges we have that <span class="math display">\[
F_{\hat{i}\hat{j}} \le Q_{ij} \quad \forall (i,j) \in E_S^\text{source}.
\]</span> Note that we do not require equality here; not all source flow has to be used.</p></li>
<li><p>Flow conservation: For the basins in the allocation graph we have that <span id="eq-flowconservationconstraint"><span class="math display">\[
  \sum_{\hat{j}=1}^{\hat{n}} F_{\hat{k}\hat{j}} \le \sum_{\hat{i}=1}^{\hat{n}} F_{\hat{i}\hat{k}} + \Phi_{\hat{k}}, \quad \forall\hat{k} \in \hat{B}_S.
\tag{2}\]</span></span> Note that we do not require equality here; in the allocation we do not mind that excess flow is ‘forgotten’ if it cannot contribute to the allocation to the users. <span class="math inline">\(\Phi_{\hat{k}}\)</span> is the local water supply of the basins: <span id="eq-basinsourceflow"><span class="math display">\[
  \Phi_{\hat{k}} = \max\left(\phi_k(t) + \frac{u_k(t)-S(l_{\min,k})}{\Delta t_\text{alloc}}, 0.0 \right).
\tag{3}\]</span></span> Here the first term denotes the vertical fluxes and the second term the flow that can be supplied by the water in the basin above its minimum level, where <span class="math inline">\(\Delta t_\text{alloc}\)</span> is the allocation solve timestep.</p></li>
<li><p>Capacity: the flows over the edges are positive and bounded by the edge capacity: <span id="eq-capacityconstraint"><span class="math display">\[
  F_{\hat{i}\hat{j}} \le \left(\hat{C}_S\right)_{\hat{i}\hat{j}}, \quad \forall(\hat{i},\hat{j}) \in \hat{E}_S.
\tag{4}\]</span></span></p></li>
<li><p>User outflow: The outflow of the user is dictated by the inflow and the return factor: <span id="eq-returnflowconstraint"><span class="math display">\[
\begin{align}
  F_{\hat{i}\hat{k}} = r_k \cdot F_{\hat{k}\hat{j}}\\
  \quad \forall\hat{k} \in \hat{U}_s, \\
  \hat{V}^{\text{in}}_S(\hat{k}) = \{\hat{i}\},\\
   \hat{V}^{\text{out}}_S(\hat{k}) = \{\hat{j}\}.
\end{align}
\tag{5}\]</span></span> Here we use that each user node in the allocation graph has an unique in-edge and out-edge.</p></li>
<li><p>User allocation: The flow over the edge to the user is equal to the sum of the allocations to the user: <span id="eq-userallocationconstraint"><span class="math display">\[
  F_{\hat{i}\hat{k}} = \sum_{p=1}^{p_\max} A^\text{user}_{\hat{k},p}, \quad \forall \hat{k} \in \hat{U}_S, \hat{V}^{\text{out}}_s(\hat{k}) = \{\hat{i}\}.
\tag{6}\]</span></span> Here we use that each user has an unique out-edge.</p></li>
<li><p>User demand: what is allocated to the user is bounded above by the user demand: <span class="math display">\[
  A_{\hat{i},p}^\text{user} \leq d_i^p(t) \quad \forall\hat{i} \in \hat{U}_S, \; p = 1,\ldots,p_\max.
\]</span></p></li>
<li><p>Basin allocation: If the flow supplied by a basin (as determined in <a href="#eq-basinsourceflow">Equation&nbsp;3</a>) is negative, it is a demand: <span id="eq-basinallocationconstraint"><span class="math display">\[
A^\text{basin}_{\hat{i}} = \max\left(-\left(\phi_i(t) + \frac{u_i(t)-S(l_{\min,k})}{\Delta t_\text{alloc}}\right), 0.0 \right), \quad \forall \hat{i} \in \hat{B}_S.
\tag{7}\]</span></span></p></li>
<li><p>Fractinal flow: Let <span class="math inline">\(\hat{L}_S \subset \hat{V}_S\)</span> be the set of nodes in the max flow graph with fractional flow outneighbors, and <span class="math inline">\(f_j\)</span> the flow fraction associated with fractional flow node <span class="math inline">\(j \in V_S\)</span>. Then <span id="eq-fractionalflowconstraint"><span class="math display">\[
\begin{align}
  F_{\hat{i}\hat{j}} = f_j \sum_{k\in \hat{V}^\text{in}_S(\hat{i})} F_{\hat{k}\hat{i}} \\
  \forall \hat{i} \in \hat{L}_S, \\
  \hat{j} \in \hat{V}_S^\text{out}(\hat{i}).
\end{align}
\tag{8}\]</span></span></p></li>
<li><p>Flow sign: Furthermore there are the non-negativity constraints for the flows and allocations, see <a href="../core/allocation.html#the-optimization-variables">The optimization variables</a>.</p></li>
</ul>
</section>
</section>
<section id="final-notes-on-the-allocation-problem" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="final-notes-on-the-allocation-problem"><span class="header-section-number">1.3</span> Final notes on the allocation problem</h2>
<section id="users-using-their-own-return-flow" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="users-using-their-own-return-flow"><span class="header-section-number">1.3.1</span> Users using their own return flow</h3>
<p>If not explicitly avoided, users can use their own return flow in this allocation problem formulation. Therefore, return flow of users is only taken into account by allocation if that return flow is downstream of the user where it comes from. That is, if there is no path in the directed allocation graph from the user outflow node back to the user.</p>
</section>
</section>
</section>
<section id="solving-the-allocation-problem" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Solving the allocation problem</h1>
<p>The text below shows a representation generated by <code>JuMP.jl</code> of an optimization as described in the previous section.</p>
<pre><code>Max A_basin[2] + A_basin[3] + A_basin[5] + 0.5 A_user_4[1] + 0.25 A_user_4[2] + 0.125 A_user_4[3] + 0.5 A_user_6[1] + 0.25 A_user_6[2] + 0.125 A_user_6[3] + 0.5 A_user_1[1] + 0.25 A_user_1[2] + 0.125 A_user_1[3]
Subject to
 allocation_sum[1] : -F[1] + A_user_1[1] + A_user_1[2] + A_user_1[3] == 0
 allocation_sum[4] : -F[3] + A_user_4[1] + A_user_4[2] + A_user_4[3] == 0
 allocation_sum[6] : -F[5] + A_user_6[1] + A_user_6[2] + A_user_6[3] == 0
 A_user_1[1] &gt;= 0
 A_user_1[2] &gt;= 0
 A_user_1[3] &gt;= 0
 A_user_4[1] &gt;= 0
 A_user_4[2] &gt;= 0
 A_user_4[3] &gt;= 0
 A_user_6[1] &gt;= 0
 A_user_6[2] &gt;= 0
 A_user_6[3] &gt;= 0
 demand_user_1[1] : A_user_1[1] &lt;= 4
 demand_user_1[2] : A_user_1[2] &lt;= 0
 demand_user_1[3] : A_user_1[3] &lt;= 0
 demand_user_4[1] : A_user_4[1] &lt;= 0
 demand_user_4[2] : A_user_4[2] &lt;= 2
 demand_user_4[3] : A_user_4[3] &lt;= 0
 demand_user_6[1] : A_user_6[1] &lt;= 0
 demand_user_6[2] : A_user_6[2] &lt;= 1
 demand_user_6[3] : A_user_6[3] &lt;= 0
 basin_allocation[2] : A_basin[2] &lt;= 0
 basin_allocation[3] : A_basin[3] &lt;= 0
 basin_allocation[5] : A_basin[5] &lt;= 0
 capacity[2] : F[2] &lt;= 3
 capacity[4] : F[4] &lt;= 4
 source[7] : F[6] &lt;= 4.5
 flow_conservation[2] : F[1] - F[2] &lt;= 0
 flow_conservation[3] : F[2] + F[3] - F[4] &lt;= 0
 flow_conservation[5] : F[4] + F[5] - F[6] &lt;= 0
 F[1] &gt;= 0
 F[2] &gt;= 0
 F[3] &gt;= 0
 F[4] &gt;= 0
 F[5] &gt;= 0
 F[6] &gt;= 0
 A_basin[2] &gt;= 0
 A_basin[3] &gt;= 0
 A_basin[5] &gt;= 0</code></pre>
<p>A more detailed explanation of this will follow in the future.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../core/equations.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Equations</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../core/numerics.html" class="pagination-link">
        <span class="nav-page-text">Numerical considerations</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>